Index: dlls/shell32/shfldr_desktop.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n/*\n *    Virtual Desktop Folder\n *\n *    Copyright 1997            Marcus Meissner\n *    Copyright 1998, 1999, 2002    Juergen Schmied\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#define COBJMACROS\n#define NONAMELESSUNION\n\n#include \"winerror.h\"\n#include \"windef.h\"\n#include \"winbase.h\"\n#include \"winreg.h\"\n#include \"wingdi.h\"\n#include \"winuser.h\"\n\n#include \"ole2.h\"\n#include \"shlguid.h\"\n\n#include \"pidl.h\"\n#include \"shell32_main.h\"\n#include \"shresdef.h\"\n#include \"shlwapi.h\"\n#include \"shellfolder.h\"\n#include \"wine/debug.h\"\n#include \"debughlp.h\"\n#include \"shfldr.h\"\n\nWINE_DEFAULT_DEBUG_CHANNEL (shell);\n\n/* Undocumented functions from shdocvw */\nextern HRESULT WINAPI IEParseDisplayNameWithBCW(DWORD codepage, LPCWSTR lpszDisplayName, LPBC pbc, LPITEMIDLIST *ppidl);\n\n/***********************************************************************\n*     Desktopfolder implementation\n*/\n\ntypedef struct {\n    IShellFolder2 IShellFolder2_iface;\n    IPersistFolder2 IPersistFolder2_iface;\n    LONG ref;\n\n    /* both paths are parsible from the desktop */\n    LPWSTR sPathTarget;     /* complete path to target used for enumeration and ChangeNotify */\n    LPITEMIDLIST pidlRoot;  /* absolute pidl */\n\n    UINT cfShellIDList;        /* clipboardformat for IDropTarget */\n    BOOL fAcceptFmt;        /* flag for pending Drop */\n} IDesktopFolderImpl;\n\nstatic IDesktopFolderImpl *cached_sf;\n\nstatic inline IDesktopFolderImpl *impl_from_IShellFolder2(IShellFolder2 *iface)\n{\n    return CONTAINING_RECORD(iface, IDesktopFolderImpl, IShellFolder2_iface);\n}\n\nstatic inline IDesktopFolderImpl *impl_from_IPersistFolder2( IPersistFolder2 *iface )\n{\n    return CONTAINING_RECORD(iface, IDesktopFolderImpl, IPersistFolder2_iface);\n}\n\nstatic const shvheader desktop_header[] =\n{\n    { &FMTID_Storage, PID_STG_NAME, IDS_SHV_COLUMN1, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT,  LVCFMT_RIGHT, 15 },\n    { &FMTID_Storage, PID_STG_SIZE, IDS_SHV_COLUMN2, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT,  LVCFMT_RIGHT, 10 },\n    { &FMTID_Storage, PID_STG_STORAGETYPE, IDS_SHV_COLUMN3, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT,  LVCFMT_RIGHT, 10 },\n    { &FMTID_Storage, PID_STG_WRITETIME, IDS_SHV_COLUMN4, SHCOLSTATE_TYPE_DATE | SHCOLSTATE_ONBYDEFAULT, LVCFMT_RIGHT, 12 },\n    { &FMTID_Storage, PID_STG_ATTRIBUTES, IDS_SHV_COLUMN5, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT,  LVCFMT_RIGHT, 5  },\n};\n\n/**************************************************************************\n *    ISF_Desktop_fnQueryInterface\n *\n */\nstatic HRESULT WINAPI ISF_Desktop_fnQueryInterface(\n                IShellFolder2 * iface, REFIID riid, LPVOID * ppvObj)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE (\"(%p)->(%s,%p)\\n\", This, shdebugstr_guid (riid), ppvObj);\n\n    if (!ppvObj) return E_POINTER;\n\n    *ppvObj = NULL;\n\n    if (IsEqualIID (riid, &IID_IUnknown) ||\n        IsEqualIID (riid, &IID_IShellFolder) ||\n        IsEqualIID (riid, &IID_IShellFolder2))\n    {\n        *ppvObj = &This->IShellFolder2_iface;\n    }\n    else if (IsEqualIID (riid, &IID_IPersist) ||\n             IsEqualIID (riid, &IID_IPersistFolder) ||\n             IsEqualIID (riid, &IID_IPersistFolder2))\n    {\n        *ppvObj = &This->IPersistFolder2_iface;\n    }\n\n    if (*ppvObj)\n    {\n        IUnknown_AddRef ((IUnknown *) (*ppvObj));\n        TRACE (\"-- Interface: (%p)->(%p)\\n\", ppvObj, *ppvObj);\n        return S_OK;\n    }\n    TRACE (\"-- Interface: E_NOINTERFACE\\n\");\n    return E_NOINTERFACE;\n}\n\nstatic ULONG WINAPI ISF_Desktop_fnAddRef (IShellFolder2 * iface)\n{\n    return 2; /* non-heap based object */\n}\n\nstatic ULONG WINAPI ISF_Desktop_fnRelease (IShellFolder2 * iface)\n{\n    return 1; /* non-heap based object */\n}\n\n/**************************************************************************\n *    ISF_Desktop_fnParseDisplayName\n *\n * NOTES\n *    \"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\" and \"\" binds\n *    to MyComputer\n */\nstatic HRESULT WINAPI ISF_Desktop_fnParseDisplayName (IShellFolder2 * iface,\n                HWND hwndOwner, LPBC pbc, LPOLESTR lpszDisplayName,\n                DWORD * pchEaten, LPITEMIDLIST * ppidl, DWORD * pdwAttributes)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n    WCHAR szElement[MAX_PATH];\n    LPCWSTR szNext = NULL;\n    LPITEMIDLIST pidlTemp = NULL;\n    PARSEDURLW urldata;\n    HRESULT hr = S_OK;\n    CLSID clsid;\n\n    TRACE (\"(%p)->(HWND=%p,%p,%p=%s,%p,pidl=%p,%p)\\n\",\n           This, hwndOwner, pbc, lpszDisplayName, debugstr_w(lpszDisplayName),\n           pchEaten, ppidl, pdwAttributes);\n\n    if (!ppidl) return E_INVALIDARG;\n    *ppidl = 0;\n\n    if (!lpszDisplayName) return E_INVALIDARG;\n\n    if (pchEaten)\n        *pchEaten = 0;        /* strange but like the original */\n\n    urldata.cbSize = sizeof(urldata);\n\n    if (lpszDisplayName[0] == ':' && lpszDisplayName[1] == ':')\n    {\n        szNext = GetNextElementW (lpszDisplayName, szElement, MAX_PATH);\n        TRACE (\"-- element: %s\\n\", debugstr_w (szElement));\n        SHCLSIDFromStringW (szElement + 2, &clsid);\n        pidlTemp = _ILCreateGuid (PT_GUID, &clsid);\n    }\n    else if (PathGetDriveNumberW (lpszDisplayName) >= 0)\n    {\n        /* it's a filesystem path with a drive. Let MyComputer/UnixDosFolder parse it */\n        pidlTemp = _ILCreateMyComputer ();\n        szNext = lpszDisplayName;\n    }\n    else if (!wcsncmp( lpszDisplayName, L\"\\\\\\\\?\\\\unix\\\\\", 9 ))\n    {\n        pidlTemp = _ILCreateGuid(PT_GUID, &CLSID_UnixDosFolder);\n        szNext = lpszDisplayName;\n    }\n    else if (PathIsUNCW(lpszDisplayName))\n    {\n        pidlTemp = _ILCreateNetwork();\n        szNext = lpszDisplayName;\n    }\n    else if( (pidlTemp = SHELL32_CreatePidlFromBindCtx(pbc, lpszDisplayName)) )\n    {\n        *ppidl = pidlTemp;\n        return S_OK;\n    }\n    else if (SUCCEEDED(ParseURLW(lpszDisplayName, &urldata)))\n    {\n        if (urldata.nScheme == URL_SCHEME_SHELL) /* handle shell: urls */\n        {\n            TRACE (\"-- shell url: %s\\n\", debugstr_w(urldata.pszSuffix));\n            SHCLSIDFromStringW (urldata.pszSuffix+2, &clsid);\n            pidlTemp = _ILCreateGuid (PT_GUID, &clsid);\n        }\n        else\n            return IEParseDisplayNameWithBCW(CP_ACP,lpszDisplayName,pbc,ppidl);\n    }\n    else\n    {\n        /* it's a filesystem path on the desktop. Let a FSFolder parse it */\n\n        if (*lpszDisplayName)\n        {\n            if (*lpszDisplayName == '/')\n            {\n                /* UNIX paths should be parsed by unixfs */\n                IShellFolder *unixFS;\n                hr = UnixFolder_Constructor(NULL, &IID_IShellFolder, (LPVOID*)&unixFS);\n                if (SUCCEEDED(hr))\n                {\n                    hr = IShellFolder_ParseDisplayName(unixFS, NULL, NULL,\n                            lpszDisplayName, NULL, &pidlTemp, NULL);\n                    IShellFolder_Release(unixFS);\n                }\n            }\n            else\n            {\n                /* build a complete path to create a simple pidl */\n                WCHAR szPath[MAX_PATH];\n                LPWSTR pathPtr;\n\n                lstrcpynW(szPath, This->sPathTarget, MAX_PATH);\n                pathPtr = PathAddBackslashW(szPath);\n                if (pathPtr)\n                {\n                    lstrcpynW(pathPtr, lpszDisplayName, MAX_PATH - (pathPtr - szPath));\n                    hr = _ILCreateFromPathW(szPath, &pidlTemp);\n                }\n                else\n                {\n                    /* should never reach here, but for completeness */\n                    hr = E_NOT_SUFFICIENT_BUFFER;\n                }\n            }\n        }\n        else\n            pidlTemp = _ILCreateMyComputer();\n\n        szNext = NULL;\n    }\n\n    if (SUCCEEDED(hr) && pidlTemp)\n    {\n        if (szNext && *szNext)\n        {\n            hr = SHELL32_ParseNextElement(iface, hwndOwner, pbc,\n                    &pidlTemp, (LPOLESTR) szNext, pchEaten, pdwAttributes);\n        }\n        else\n        {\n            if (pdwAttributes && *pdwAttributes)\n                hr = SHELL32_GetItemAttributes(iface, pidlTemp, pdwAttributes);\n        }\n    }\n\n    *ppidl = pidlTemp;\n\n    TRACE (\"(%p)->(-- ret=0x%08lx)\\n\", This, hr);\n\n    return hr;\n}\n\nstatic void add_shell_namespace_extensions(IEnumIDListImpl *list, HKEY root)\n{\n    WCHAR guid[39], clsidkeyW[60];\n    DWORD size, i = 0;\n    HKEY hkey;\n\n    if (RegOpenKeyExW(root, L\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Desktop\\\\Namespace\", 0, KEY_READ, &hkey))\n        return;\n\n    size = ARRAY_SIZE(guid);\n    while (!RegEnumKeyExW(hkey, i++, guid, &size, 0, NULL, NULL, NULL))\n    {\n        DWORD attributes, value_size = sizeof(attributes);\n\n        /* Check if extension is configured as nonenumerable */\n        swprintf(clsidkeyW, ARRAY_SIZE(clsidkeyW), L\"CLSID\\\\%s\\\\ShellFolder\", guid);\n        RegGetValueW(HKEY_CLASSES_ROOT, clsidkeyW, L\"Attributes\", RRF_RT_REG_DWORD | RRF_ZEROONFAILURE,\n            NULL, &attributes, &value_size);\n\n        if (!(attributes & SFGAO_NONENUMERATED))\n            AddToEnumList(list, _ILCreateGuidFromStrW(guid));\n        size = ARRAY_SIZE(guid);\n    }\n\n    RegCloseKey(hkey);\n}\n\n/**************************************************************************\n *  CreateDesktopEnumList()\n */\nstatic BOOL CreateDesktopEnumList(IEnumIDListImpl *list, DWORD dwFlags)\n{\n    BOOL ret = TRUE;\n    WCHAR szPath[MAX_PATH];\n\n    TRACE(\"(%p)->(flags=0x%08lx)\\n\", list, dwFlags);\n\n    /* enumerate the root folders */\n    if (dwFlags & SHCONTF_FOLDERS)\n    {\n        ret = AddToEnumList(list, _ILCreateMyComputer());\n        add_shell_namespace_extensions(list, HKEY_LOCAL_MACHINE);\n        add_shell_namespace_extensions(list, HKEY_CURRENT_USER);\n    }\n\n    /* enumerate the elements in %windir%\\desktop */\n    ret = ret && SHGetSpecialFolderPathW(0, szPath, CSIDL_DESKTOPDIRECTORY, FALSE);\n    ret = ret && CreateFolderEnumList(list, szPath, dwFlags);\n\n    return ret;\n}\n\n/**************************************************************************\n *        ISF_Desktop_fnEnumObjects\n */\nstatic HRESULT WINAPI ISF_Desktop_fnEnumObjects (IShellFolder2 * iface,\n                HWND hwndOwner, DWORD dwFlags, LPENUMIDLIST * ppEnumIDList)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n    IEnumIDListImpl *list;\n\n    TRACE (\"(%p)->(HWND=%p flags=0x%08lx pplist=%p)\\n\",\n           This, hwndOwner, dwFlags, ppEnumIDList);\n\n    if (!(list = IEnumIDList_Constructor()))\n        return E_OUTOFMEMORY;\n    CreateDesktopEnumList(list, dwFlags);\n    *ppEnumIDList = &list->IEnumIDList_iface;\n\n    TRACE (\"-- (%p)->(new ID List: %p)\\n\", This, *ppEnumIDList);\n\n    return S_OK;\n}\n\n/**************************************************************************\n *        ISF_Desktop_fnBindToObject\n */\nstatic HRESULT WINAPI ISF_Desktop_fnBindToObject (IShellFolder2 * iface,\n                LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvOut)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE (\"(%p)->(pidl=%p,%p,%s,%p)\\n\",\n           This, pidl, pbcReserved, shdebugstr_guid (riid), ppvOut);\n\n    return SHELL32_BindToChild( This->pidlRoot, &CLSID_ShellFSFolder, This->sPathTarget, pidl, riid, ppvOut );\n}\n\n/**************************************************************************\n *    ISF_Desktop_fnBindToStorage\n */\nstatic HRESULT WINAPI ISF_Desktop_fnBindToStorage (IShellFolder2 * iface,\n                LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvOut)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    FIXME (\"(%p)->(pidl=%p,%p,%s,%p) stub\\n\",\n           This, pidl, pbcReserved, shdebugstr_guid (riid), ppvOut);\n\n    *ppvOut = NULL;\n    return E_NOTIMPL;\n}\n\n/**************************************************************************\n *     ISF_Desktop_fnCompareIDs\n */\nstatic HRESULT WINAPI ISF_Desktop_fnCompareIDs (IShellFolder2 *iface,\n                        LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n    HRESULT hr;\n\n    TRACE (\"(%p)->(0x%08Ix,pidl1=%p,pidl2=%p)\\n\", This, lParam, pidl1, pidl2);\n    hr = SHELL32_CompareIDs(iface, lParam, pidl1, pidl2);\n    TRACE (\"-- 0x%08lx\\n\", hr);\n    return hr;\n}\n\n/**************************************************************************\n *    ISF_Desktop_fnCreateViewObject\n */\nstatic HRESULT WINAPI ISF_Desktop_fnCreateViewObject (IShellFolder2 * iface,\n                              HWND hwndOwner, REFIID riid, LPVOID * ppvOut)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n    LPSHELLVIEW pShellView;\n    HRESULT hr = E_INVALIDARG;\n\n    TRACE (\"(%p)->(hwnd=%p,%s,%p)\\n\",\n           This, hwndOwner, shdebugstr_guid (riid), ppvOut);\n\n    if (!ppvOut)\n        return E_INVALIDARG;\n\n    *ppvOut = NULL;\n\n    if (IsEqualIID (riid, &IID_IDropTarget))\n    {\n        WARN (\"IDropTarget not implemented\\n\");\n        hr = E_NOTIMPL;\n    }\n    else if (IsEqualIID (riid, &IID_IContextMenu))\n    {\n        hr = BackgroundMenu_Constructor((IShellFolder*)iface, TRUE, riid, ppvOut);\n    }\n    else if (IsEqualIID (riid, &IID_IShellView))\n    {\n        pShellView = IShellView_Constructor ((IShellFolder *) iface);\n        if (pShellView)\n        {\n            hr = IShellView_QueryInterface (pShellView, riid, ppvOut);\n            IShellView_Release (pShellView);\n        }\n    }\n    TRACE (\"-- (%p)->(interface=%p)\\n\", This, ppvOut);\n    return hr;\n}\n\n/**************************************************************************\n *  ISF_Desktop_fnGetAttributesOf\n */\nstatic HRESULT WINAPI ISF_Desktop_fnGetAttributesOf (IShellFolder2 * iface,\n                UINT cidl, LPCITEMIDLIST * apidl, DWORD * rgfInOut)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    static const DWORD dwDesktopAttributes = \n        SFGAO_STORAGE | SFGAO_HASPROPSHEET | SFGAO_STORAGEANCESTOR |\n        SFGAO_FILESYSANCESTOR | SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_HASSUBFOLDER;\n    static const DWORD dwMyComputerAttributes = \n        SFGAO_CANRENAME | SFGAO_CANDELETE | SFGAO_HASPROPSHEET |\n        SFGAO_DROPTARGET | SFGAO_FILESYSANCESTOR | SFGAO_FOLDER | SFGAO_HASSUBFOLDER;\n\n    TRACE (\"(%p)->(cidl=%d apidl=%p mask=%p (0x%08lx))\\n\",\n           This, cidl, apidl, rgfInOut, rgfInOut ? *rgfInOut : 0);\n\n    if (!rgfInOut)\n        return E_INVALIDARG;\n    if (cidl && !apidl)\n        return E_INVALIDARG;\n\n    if (*rgfInOut == 0)\n        *rgfInOut = ~0;\n    \n    if(cidl == 0) {\n        *rgfInOut &= dwDesktopAttributes; \n    } else {\n        while (cidl > 0 && *apidl) {\n            pdump (*apidl);\n            if (_ILIsDesktop(*apidl)) { \n                *rgfInOut &= dwDesktopAttributes;\n            } else if (_ILIsMyComputer(*apidl)) {\n                *rgfInOut &= dwMyComputerAttributes;\n            } else {\n                SHELL32_GetItemAttributes(iface, *apidl, rgfInOut);\n            }\n            apidl++;\n            cidl--;\n        }\n    }\n    /* make sure SFGAO_VALIDATE is cleared, some apps depend on that */\n    *rgfInOut &= ~SFGAO_VALIDATE;\n\n    TRACE (\"-- result=0x%08lx\\n\", *rgfInOut);\n\n    return S_OK;\n}\n\n/**************************************************************************\n *    ISF_Desktop_fnGetUIObjectOf\n *\n * PARAMETERS\n *  HWND           hwndOwner, //[in ] Parent window for any output\n *  UINT           cidl,      //[in ] array size\n *  LPCITEMIDLIST* apidl,     //[in ] simple pidl array\n *  REFIID         riid,      //[in ] Requested Interface\n *  UINT*          prgfInOut, //[   ] reserved\n *  LPVOID*        ppvObject) //[out] Resulting Interface\n *\n */\nstatic HRESULT WINAPI ISF_Desktop_fnGetUIObjectOf (IShellFolder2 * iface,\n                HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,\n                REFIID riid, UINT * prgfInOut, LPVOID * ppvOut)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    LPITEMIDLIST pidl;\n    IUnknown *pObj = NULL;\n    HRESULT hr = E_INVALIDARG;\n\n    TRACE (\"(%p)->(%p,%u,apidl=%p,%s,%p,%p)\\n\",\n       This, hwndOwner, cidl, apidl, shdebugstr_guid (riid), prgfInOut, ppvOut);\n\n    if (!ppvOut)\n        return E_INVALIDARG;\n\n    *ppvOut = NULL;\n\n    if (IsEqualIID (riid, &IID_IContextMenu))\n    {\n        if (cidl > 0)\n            return ItemMenu_Constructor((IShellFolder*)iface, This->pidlRoot, apidl, cidl, riid, ppvOut);\n        else\n            return BackgroundMenu_Constructor((IShellFolder*)iface, TRUE, riid, ppvOut);\n    }\n    else if (IsEqualIID (riid, &IID_IDataObject) && (cidl >= 1))\n    {\n        pObj = (LPUNKNOWN) IDataObject_Constructor( hwndOwner,\n                                                  This->pidlRoot, apidl, cidl);\n        hr = S_OK;\n    }\n    else if (IsEqualIID (riid, &IID_IExtractIconA) && (cidl == 1))\n    {\n        pidl = ILCombine (This->pidlRoot, apidl[0]);\n        pObj = (LPUNKNOWN) IExtractIconA_Constructor (pidl);\n        SHFree (pidl);\n        hr = S_OK;\n    }\n    else if (IsEqualIID (riid, &IID_IExtractIconW) && (cidl == 1))\n    {\n        pidl = ILCombine (This->pidlRoot, apidl[0]);\n        pObj = (LPUNKNOWN) IExtractIconW_Constructor (pidl);\n        SHFree (pidl);\n        hr = S_OK;\n    }\n    else if (IsEqualIID (riid, &IID_IDropTarget) && (cidl >= 1))\n    {\n        hr = IShellFolder2_QueryInterface (iface,\n                                          &IID_IDropTarget, (LPVOID *) & pObj);\n    }\n    else if ((IsEqualIID(riid,&IID_IShellLinkW) ||\n              IsEqualIID(riid,&IID_IShellLinkA)) && (cidl == 1))\n    {\n        pidl = ILCombine (This->pidlRoot, apidl[0]);\n        hr = IShellLink_ConstructFromFile(NULL, riid, pidl, &pObj);\n        SHFree (pidl);\n    }\n    else\n        hr = E_NOINTERFACE;\n\n    if (SUCCEEDED(hr) && !pObj)\n        hr = E_OUTOFMEMORY;\n\n    *ppvOut = pObj;\n    TRACE (\"(%p)->hr=0x%08lx\\n\", This, hr);\n    return hr;\n}\n\n/**************************************************************************\n *    ISF_Desktop_fnGetDisplayNameOf\n *\n * NOTES\n *    special case: pidl = null gives desktop-name back\n */\nstatic HRESULT WINAPI ISF_Desktop_fnGetDisplayNameOf (IShellFolder2 * iface,\n                LPCITEMIDLIST pidl, DWORD dwFlags, LPSTRRET strRet)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n    HRESULT hr = S_OK;\n    LPWSTR pszPath;\n\n    TRACE (\"(%p)->(pidl=%p,0x%08lx,%p)\\n\", This, pidl, dwFlags, strRet);\n    pdump (pidl);\n\n    if (!strRet)\n        return E_INVALIDARG;\n\n    pszPath = CoTaskMemAlloc((MAX_PATH +1) * sizeof(WCHAR));\n    if (!pszPath)\n        return E_OUTOFMEMORY;\n\n    if (_ILIsDesktop (pidl))\n    {\n        if ((GET_SHGDN_RELATION (dwFlags) == SHGDN_NORMAL) &&\n            (GET_SHGDN_FOR (dwFlags) & SHGDN_FORPARSING))\n            lstrcpyW(pszPath, This->sPathTarget);\n        else\n            HCR_GetClassNameW(&CLSID_ShellDesktop, pszPath, MAX_PATH);\n    }\n    else if (_ILIsPidlSimple (pidl))\n    {\n        GUID const *clsid;\n\n        if ((clsid = _ILGetGUIDPointer (pidl)))\n        {\n            if ((GET_SHGDN_FOR (dwFlags) & (SHGDN_FORPARSING | SHGDN_FORADDRESSBAR)) == SHGDN_FORPARSING)\n            {\n                BOOL bWantsForParsing;\n\n                /*\n                 * We can only get a filesystem path from a shellfolder if the\n                 *  value WantsFORPARSING in CLSID\\\\{...}\\\\shellfolder exists.\n                 *\n                 * Exception: The MyComputer folder doesn't have this key,\n                 *   but any other filesystem backed folder it needs it.\n                 */\n                if (IsEqualIID (clsid, &CLSID_MyComputer))\n                {\n                    bWantsForParsing = TRUE;\n                }\n                else\n                {\n                    /* get the \"WantsFORPARSING\" flag from the registry */\n                    WCHAR szRegPath[100];\n                    LONG r;\n\n                    lstrcpyW (szRegPath, L\"CLSID\\\\\");\n                    SHELL32_GUIDToStringW (clsid, &szRegPath[6]);\n                    lstrcatW (szRegPath, L\"\\\\shellfolder\");\n                    r = SHGetValueW(HKEY_CLASSES_ROOT, szRegPath, L\"WantsForParsing\", NULL, NULL, NULL);\n                    if (r == ERROR_SUCCESS)\n                        bWantsForParsing = TRUE;\n                    else\n                        bWantsForParsing = FALSE;\n                }\n\n                if ((GET_SHGDN_RELATION (dwFlags) == SHGDN_NORMAL) &&\n                     bWantsForParsing)\n                {\n                    /*\n                     * we need the filesystem path to the destination folder.\n                     * Only the folder itself can know it\n                     */\n                    hr = SHELL32_GetDisplayNameOfChild (iface, pidl, dwFlags,\n                                                        pszPath,\n                                                        MAX_PATH);\n                }\n                else\n                {\n                    /* parsing name like ::{...} */\n                    pszPath[0] = ':';\n                    pszPath[1] = ':';\n                    SHELL32_GUIDToStringW (clsid, &pszPath[2]);\n                }\n            }\n            else\n            {\n                /* user friendly name */\n                HCR_GetClassNameW (clsid, pszPath, MAX_PATH);\n            }\n        }\n        else\n        {\n            int cLen = 0;\n\n            /* file system folder or file rooted at the desktop */\n            if ((GET_SHGDN_FOR(dwFlags) == SHGDN_FORPARSING) &&\n                (GET_SHGDN_RELATION(dwFlags) != SHGDN_INFOLDER))\n            {\n                lstrcpynW(pszPath, This->sPathTarget, MAX_PATH - 1);\n                PathAddBackslashW(pszPath);\n                cLen = lstrlenW(pszPath);\n            }\n\n            _ILSimpleGetTextW(pidl, pszPath + cLen, MAX_PATH - cLen);\n\n            if (!_ILIsFolder(pidl))\n                SHELL_FS_ProcessDisplayFilename(pszPath, dwFlags);\n        }\n    }\n    else\n    {\n        /* a complex pidl, let the subfolder do the work */\n        hr = SHELL32_GetDisplayNameOfChild (iface, pidl, dwFlags,\n                                            pszPath, MAX_PATH);\n    }\n\n    if (SUCCEEDED(hr))\n    {\n        /* Win9x always returns ANSI strings, NT always returns Unicode strings */\n        if (GetVersion() & 0x80000000)\n        {\n            strRet->uType = STRRET_CSTR;\n            if (!WideCharToMultiByte(CP_ACP, 0, pszPath, -1, strRet->u.cStr, MAX_PATH,\n                                     NULL, NULL))\n                strRet->u.cStr[0] = '\\0';\n            CoTaskMemFree(pszPath);\n        }\n        else\n        {\n            strRet->uType = STRRET_WSTR;\n            strRet->u.pOleStr = pszPath;\n        }\n    }\n    else\n        CoTaskMemFree(pszPath);\n\n    TRACE (\"-- (%p)->(%s,0x%08lx)\\n\", This,\n    strRet->uType == STRRET_CSTR ? strRet->u.cStr :\n    debugstr_w(strRet->u.pOleStr), hr);\n    return hr;\n}\n\n/**************************************************************************\n *  ISF_Desktop_fnSetNameOf\n *  Changes the name of a file object or subfolder, possibly changing its item\n *  identifier in the process.\n *\n * PARAMETERS\n *  HWND          hwndOwner,  //[in ] Owner window for output\n *  LPCITEMIDLIST pidl,       //[in ] simple pidl of item to change\n *  LPCOLESTR     lpszName,   //[in ] the items new display name\n *  DWORD         dwFlags,    //[in ] SHGNO formatting flags\n *  LPITEMIDLIST* ppidlOut)   //[out] simple pidl returned\n */\nstatic HRESULT WINAPI ISF_Desktop_fnSetNameOf (IShellFolder2 * iface,\n                HWND hwndOwner, LPCITEMIDLIST pidl,    /* simple pidl */\n                LPCOLESTR lpName, DWORD dwFlags, LPITEMIDLIST * pPidlOut)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    FIXME (\"(%p)->(%p,pidl=%p,%s,%lu,%p) stub\\n\", This, hwndOwner, pidl,\n           debugstr_w (lpName), dwFlags, pPidlOut);\n\n    return E_FAIL;\n}\n\nstatic HRESULT WINAPI ISF_Desktop_fnGetDefaultSearchGUID(IShellFolder2 *iface, GUID *guid)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n    TRACE(\"(%p)->(%p)\\n\", This, guid);\n    return E_NOTIMPL;\n}\n\nstatic HRESULT WINAPI ISF_Desktop_fnEnumSearches (IShellFolder2 *iface,\n                IEnumExtraSearch ** ppenum)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n    FIXME (\"(%p)->(%p) stub\\n\", This, ppenum);\n    return E_NOTIMPL;\n}\n\nstatic HRESULT WINAPI ISF_Desktop_fnGetDefaultColumn(IShellFolder2 *iface, DWORD reserved, ULONG *sort, ULONG *display)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE (\"(%p)->(%#lx, %p, %p)\\n\", This, reserved, sort, display);\n\n    return E_NOTIMPL;\n}\n\nstatic HRESULT WINAPI ISF_Desktop_fnGetDefaultColumnState (\n                IShellFolder2 * iface, UINT iColumn, DWORD * pcsFlags)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE (\"(%p)->(%d %p)\\n\", This, iColumn, pcsFlags);\n\n    if (!pcsFlags || iColumn >= ARRAY_SIZE(desktop_header))\n        return E_INVALIDARG;\n\n    *pcsFlags = desktop_header[iColumn].pcsFlags;\n\n    return S_OK;\n}\n\nstatic HRESULT WINAPI ISF_Desktop_fnGetDetailsEx (IShellFolder2 * iface,\n                LPCITEMIDLIST pidl, const SHCOLUMNID * pscid, VARIANT * pv)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n    FIXME (\"(%p)->(%p %p %p) stub\\n\", This, pidl, pscid, pv);\n    return E_NOTIMPL;\n}\n\nstatic HRESULT WINAPI ISF_Desktop_fnGetDetailsOf (IShellFolder2 * iface,\n                LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS * psd)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE (\"(%p)->(%p %i %p)\\n\", This, pidl, iColumn, psd);\n\n    if (!psd || iColumn >= ARRAY_SIZE(desktop_header))\n        return E_INVALIDARG;\n\n    if (!pidl)\n        return SHELL32_GetColumnDetails(desktop_header, iColumn, psd);\n\n    return shellfolder_get_file_details( iface, pidl, desktop_header, iColumn, psd );\n}\n\nstatic HRESULT WINAPI ISF_Desktop_fnMapColumnToSCID(IShellFolder2 *iface, UINT column, SHCOLUMNID *scid)\n{\n    IDesktopFolderImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE(\"(%p)->(%u %p)\\n\", This, column, scid);\n\n    if (column >= ARRAY_SIZE(desktop_header))\n        return E_INVALIDARG;\n\n    return shellfolder_map_column_to_scid(desktop_header, column, scid);\n}\n\nstatic const IShellFolder2Vtbl vt_MCFldr_ShellFolder2 =\n{\n    ISF_Desktop_fnQueryInterface,\n    ISF_Desktop_fnAddRef,\n    ISF_Desktop_fnRelease,\n    ISF_Desktop_fnParseDisplayName,\n    ISF_Desktop_fnEnumObjects,\n    ISF_Desktop_fnBindToObject,\n    ISF_Desktop_fnBindToStorage,\n    ISF_Desktop_fnCompareIDs,\n    ISF_Desktop_fnCreateViewObject,\n    ISF_Desktop_fnGetAttributesOf,\n    ISF_Desktop_fnGetUIObjectOf,\n    ISF_Desktop_fnGetDisplayNameOf,\n    ISF_Desktop_fnSetNameOf,\n    /* ShellFolder2 */\n    ISF_Desktop_fnGetDefaultSearchGUID,\n    ISF_Desktop_fnEnumSearches,\n    ISF_Desktop_fnGetDefaultColumn,\n    ISF_Desktop_fnGetDefaultColumnState,\n    ISF_Desktop_fnGetDetailsEx,\n    ISF_Desktop_fnGetDetailsOf,\n    ISF_Desktop_fnMapColumnToSCID\n};\n\n/**************************************************************************\n *    IPersist\n */\nstatic HRESULT WINAPI ISF_Desktop_IPersistFolder2_fnQueryInterface(\n    IPersistFolder2 *iface, REFIID riid, LPVOID *ppvObj)\n{\n    IDesktopFolderImpl *This = impl_from_IPersistFolder2( iface );\n    return IShellFolder2_QueryInterface(&This->IShellFolder2_iface, riid, ppvObj);\n}\n\nstatic ULONG WINAPI ISF_Desktop_IPersistFolder2_fnAddRef(\n    IPersistFolder2 *iface)\n{\n    IDesktopFolderImpl *This = impl_from_IPersistFolder2( iface );\n    return IShellFolder2_AddRef(&This->IShellFolder2_iface);\n}\n\nstatic ULONG WINAPI ISF_Desktop_IPersistFolder2_fnRelease(\n    IPersistFolder2 *iface)\n{\n    IDesktopFolderImpl *This = impl_from_IPersistFolder2( iface );\n    return IShellFolder2_Release(&This->IShellFolder2_iface);\n}\n\nstatic HRESULT WINAPI ISF_Desktop_IPersistFolder2_fnGetClassID(\n    IPersistFolder2 *iface, CLSID *clsid)\n{\n    *clsid = CLSID_ShellDesktop;\n    return S_OK;\n}\nstatic HRESULT WINAPI ISF_Desktop_IPersistFolder2_fnInitialize(\n    IPersistFolder2 *iface, LPCITEMIDLIST pidl)\n{\n    IDesktopFolderImpl *This = impl_from_IPersistFolder2( iface );\n    FIXME (\"(%p)->(%p) stub\\n\", This, pidl);\n    return E_NOTIMPL;\n}\nstatic HRESULT WINAPI ISF_Desktop_IPersistFolder2_fnGetCurFolder(\n    IPersistFolder2 *iface, LPITEMIDLIST *ppidl)\n{\n    IDesktopFolderImpl *This = impl_from_IPersistFolder2( iface );\n    *ppidl = ILClone(This->pidlRoot);\n    return S_OK;\n}\n\nstatic const IPersistFolder2Vtbl vt_IPersistFolder2 =\n{\n    ISF_Desktop_IPersistFolder2_fnQueryInterface,\n    ISF_Desktop_IPersistFolder2_fnAddRef,\n    ISF_Desktop_IPersistFolder2_fnRelease,\n    ISF_Desktop_IPersistFolder2_fnGetClassID,\n    ISF_Desktop_IPersistFolder2_fnInitialize,\n    ISF_Desktop_IPersistFolder2_fnGetCurFolder\n};\n\nvoid release_desktop_folder(void)\n{\n    if (!cached_sf) return;\n    SHFree(cached_sf->pidlRoot);\n    SHFree(cached_sf->sPathTarget);\n    LocalFree(cached_sf);\n}\n\n/**************************************************************************\n *    ISF_Desktop_Constructor\n */\nHRESULT WINAPI ISF_Desktop_Constructor (\n                IUnknown * pUnkOuter, REFIID riid, LPVOID * ppv)\n{\n    WCHAR szMyPath[MAX_PATH];\n\n    TRACE (\"unkOut=%p %s\\n\", pUnkOuter, shdebugstr_guid (riid));\n\n    if (!ppv)\n        return E_POINTER;\n    if (pUnkOuter)\n        return CLASS_E_NOAGGREGATION;\n\n    if (!cached_sf)\n    {\n        IDesktopFolderImpl *sf;\n\n        if (!SHGetSpecialFolderPathW( 0, szMyPath, CSIDL_DESKTOPDIRECTORY, TRUE ))\n            return E_UNEXPECTED;\n\n        sf = LocalAlloc( LMEM_ZEROINIT, sizeof (IDesktopFolderImpl) );\n        if (!sf)\n            return E_OUTOFMEMORY;\n\n        sf->ref = 1;\n        sf->IShellFolder2_iface.lpVtbl = &vt_MCFldr_ShellFolder2;\n        sf->IPersistFolder2_iface.lpVtbl = &vt_IPersistFolder2;\n        sf->pidlRoot = _ILCreateDesktop();    /* my qualified pidl */\n        sf->sPathTarget = SHAlloc( (lstrlenW(szMyPath) + 1)*sizeof(WCHAR) );\n        lstrcpyW( sf->sPathTarget, szMyPath );\n\n        if (InterlockedCompareExchangePointer((void *)&cached_sf, sf, NULL) != NULL)\n        {\n            /* some other thread already been here */\n            SHFree( sf->pidlRoot );\n            SHFree( sf->sPathTarget );\n            LocalFree( sf );\n        }\n    }\n\n    return IShellFolder2_QueryInterface( &cached_sf->IShellFolder2_iface, riid, ppv );\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dlls/shell32/shfldr_desktop.c b/dlls/shell32/shfldr_desktop.c
--- a/dlls/shell32/shfldr_desktop.c	(revision 3c875fb65750ab683d74d606b39a964855a6259f)
+++ b/dlls/shell32/shfldr_desktop.c	(date 1694966785381)
@@ -181,12 +181,10 @@
     else if (PathGetDriveNumberW (lpszDisplayName) >= 0)
     {
         /* it's a filesystem path with a drive. Let MyComputer/UnixDosFolder parse it */
-        pidlTemp = _ILCreateMyComputer ();
-        szNext = lpszDisplayName;
-    }
-    else if (!wcsncmp( lpszDisplayName, L"\\\\?\\unix\\", 9 ))
-    {
-        pidlTemp = _ILCreateGuid(PT_GUID, &CLSID_UnixDosFolder);
+        if (UNIXFS_is_rooted_at_desktop())
+            pidlTemp = _ILCreateGuid(PT_GUID, &CLSID_UnixDosFolder);
+        else
+            pidlTemp = _ILCreateMyComputer ();
         szNext = lpszDisplayName;
     }
     else if (PathIsUNCW(lpszDisplayName))
Index: dlls/shell32/shfldr_fs.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\n/*\n * file system folder\n *\n * Copyright 1997             Marcus Meissner\n * Copyright 1998, 1999, 2002 Juergen Schmied\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#define COBJMACROS\n#define NONAMELESSUNION\n\n#include \"winerror.h\"\n#include \"windef.h\"\n#include \"winbase.h\"\n#include \"winreg.h\"\n#include \"wingdi.h\"\n#include \"winuser.h\"\n\n#include \"ole2.h\"\n#include \"shlguid.h\"\n\n#include \"pidl.h\"\n#include \"shell32_main.h\"\n#include \"shresdef.h\"\n#include \"shlwapi.h\"\n#include \"shellfolder.h\"\n#include \"wine/debug.h\"\n#include \"debughlp.h\"\n#include \"shfldr.h\"\n\nWINE_DEFAULT_DEBUG_CHANNEL (shell);\n\n/***********************************************************************\n*   IShellFolder implementation\n*/\n\ntypedef struct {\n    IUnknown IUnknown_inner;\n    LONG ref;\n    IShellFolder2 IShellFolder2_iface;\n    IPersistFolder3 IPersistFolder3_iface;\n    IPersistPropertyBag IPersistPropertyBag_iface;\n    IDropTarget IDropTarget_iface;\n    ISFHelper ISFHelper_iface;\n    IUnknown *outer_unk;\n\n    const CLSID *pclsid;\n\n    /* both paths are parsible from the desktop */\n    LPWSTR sPathTarget;     /* complete path to target used for enumeration and ChangeNotify */\n\n    LPITEMIDLIST pidlRoot; /* absolute pidl */\n    DWORD drop_effects_mask;\n} IGenericSFImpl;\n\nstatic UINT cfShellIDList;\n\nstatic inline IGenericSFImpl *impl_from_IUnknown(IUnknown *iface)\n{\n    return CONTAINING_RECORD(iface, IGenericSFImpl, IUnknown_inner);\n}\n\nstatic inline IGenericSFImpl *impl_from_IShellFolder2(IShellFolder2 *iface)\n{\n    return CONTAINING_RECORD(iface, IGenericSFImpl, IShellFolder2_iface);\n}\n\nstatic inline IGenericSFImpl *impl_from_IPersistFolder3(IPersistFolder3 *iface)\n{\n    return CONTAINING_RECORD(iface, IGenericSFImpl, IPersistFolder3_iface);\n}\n\nstatic inline IGenericSFImpl *impl_from_IPersistPropertyBag(IPersistPropertyBag *iface)\n{\n    return CONTAINING_RECORD(iface, IGenericSFImpl, IPersistPropertyBag_iface);\n}\n\nstatic inline IGenericSFImpl *impl_from_IDropTarget(IDropTarget *iface)\n{\n    return CONTAINING_RECORD(iface, IGenericSFImpl, IDropTarget_iface);\n}\n\nstatic inline IGenericSFImpl *impl_from_ISFHelper(ISFHelper *iface)\n{\n    return CONTAINING_RECORD(iface, IGenericSFImpl, ISFHelper_iface);\n}\n\n/**************************************************************************\n* inner IUnknown\n*/\nstatic HRESULT WINAPI IUnknown_fnQueryInterface(IUnknown *iface, REFIID riid, void **ppvObj)\n{\n    IGenericSFImpl *This = impl_from_IUnknown(iface);\n\n    TRACE(\"(%p)->(%s,%p)\\n\", This, shdebugstr_guid(riid), ppvObj);\n\n    *ppvObj = NULL;\n\n    if (IsEqualIID (riid, &IID_IUnknown))\n        *ppvObj = &This->IUnknown_inner;\n    else if (IsEqualIID(riid, &IID_IShellFolder) || IsEqualIID(riid, &IID_IShellFolder2))\n        *ppvObj = &This->IShellFolder2_iface;\n    else if (IsEqualIID(riid, &IID_IPersist) || IsEqualIID(riid, &IID_IPersistFolder) ||\n            IsEqualIID(riid, &IID_IPersistFolder2) || IsEqualIID(riid, &IID_IPersistFolder3))\n        *ppvObj = &This->IPersistFolder3_iface;\n    else if (IsEqualIID(&IID_IPersistPropertyBag, riid))\n        *ppvObj = &This->IPersistPropertyBag_iface;\n    else if (IsEqualIID (riid, &IID_ISFHelper))\n        *ppvObj = &This->ISFHelper_iface;\n    else if (IsEqualIID (riid, &IID_IDropTarget)) {\n        *ppvObj = &This->IDropTarget_iface;\n        if (!cfShellIDList) cfShellIDList = RegisterClipboardFormatW(CFSTR_SHELLIDLISTW);\n    }\n\n    if (*ppvObj) {\n        IUnknown_AddRef((IUnknown *)*ppvObj);\n        TRACE (\"-- Interface = %p\\n\", *ppvObj);\n        return S_OK;\n    }\n    TRACE (\"-- Interface: E_NOINTERFACE\\n\");\n    return E_NOINTERFACE;\n}\n\nstatic ULONG WINAPI IUnknown_fnAddRef(IUnknown *iface)\n{\n    IGenericSFImpl *This = impl_from_IUnknown(iface);\n    ULONG ref = InterlockedIncrement(&This->ref);\n\n    TRACE(\"(%p) ref=%ld\\n\", This, ref);\n\n    return ref;\n}\n\nstatic ULONG WINAPI IUnknown_fnRelease(IUnknown *iface)\n{\n    IGenericSFImpl *This = impl_from_IUnknown(iface);\n    ULONG ref = InterlockedDecrement(&This->ref);\n\n    TRACE(\"(%p) ref=%ld\\n\", This, ref);\n\n    if (!ref) {\n        TRACE(\"-- destroying IShellFolder(%p)\\n\", This);\n\n        SHFree(This->pidlRoot);\n        SHFree(This->sPathTarget);\n        LocalFree(This);\n    }\n    return ref;\n}\n\nstatic const IUnknownVtbl unkvt =\n{\n      IUnknown_fnQueryInterface,\n      IUnknown_fnAddRef,\n      IUnknown_fnRelease,\n};\n\nstatic const shvheader GenericSFHeader[] =\n{\n    { &FMTID_Storage, PID_STG_NAME,        IDS_SHV_COLUMN1, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT,  LVCFMT_RIGHT, 15 },\n    { &FMTID_Storage, PID_STG_SIZE,        IDS_SHV_COLUMN2, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT,  LVCFMT_RIGHT, 10 },\n    { &FMTID_Storage, PID_STG_STORAGETYPE, IDS_SHV_COLUMN3, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT,  LVCFMT_RIGHT, 10 },\n    { &FMTID_Storage, PID_STG_WRITETIME,   IDS_SHV_COLUMN4, SHCOLSTATE_TYPE_DATE | SHCOLSTATE_ONBYDEFAULT, LVCFMT_RIGHT, 12 },\n    { &FMTID_Storage, PID_STG_ATTRIBUTES,  IDS_SHV_COLUMN5, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT,  LVCFMT_RIGHT, 5  },\n};\n\n#define GENERICSHELLVIEWCOLUMNS 5\n\n/**************************************************************************\n *  IShellFolder_fnQueryInterface\n */\nstatic HRESULT WINAPI IShellFolder_fnQueryInterface(IShellFolder2 *iface, REFIID riid,\n        void **ppvObj)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    return IUnknown_QueryInterface(This->outer_unk, riid, ppvObj);\n}\n\n/**************************************************************************\n*  IShellFolder_AddRef\n*/\nstatic ULONG WINAPI IShellFolder_fnAddRef(IShellFolder2 *iface)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    return IUnknown_AddRef(This->outer_unk);\n}\n\n/**************************************************************************\n *  IShellFolder_fnRelease\n */\nstatic ULONG WINAPI IShellFolder_fnRelease(IShellFolder2 *iface)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    return IUnknown_Release(This->outer_unk);\n}\n\n/**************************************************************************\n *  SHELL32_CreatePidlFromBindCtx  [internal]\n *\n *  If the caller bound File System Bind Data, assume it is the \n *   find data for the path.\n *  This allows binding of paths that don't exist.\n */\nLPITEMIDLIST SHELL32_CreatePidlFromBindCtx(IBindCtx *pbc, LPCWSTR path)\n{\n    IFileSystemBindData *fsbd = NULL;\n    LPITEMIDLIST pidl = NULL;\n    IUnknown *unk = NULL;\n    HRESULT r;\n\n    TRACE(\"%p %s\\n\", pbc, debugstr_w(path));\n\n    if (!pbc)\n        return NULL;\n\n    /* see if the caller bound File System Bind Data */\n    r = IBindCtx_GetObjectParam( pbc, (WCHAR *)L\"File System Bind Data\", &unk );\n    if (FAILED(r))\n        return NULL;\n\n    r = IUnknown_QueryInterface( unk, &IID_IFileSystemBindData, (void**)&fsbd );\n    if (SUCCEEDED(r))\n    {\n        WIN32_FIND_DATAW wfd;\n\n        r = IFileSystemBindData_GetFindData( fsbd, &wfd );\n        if (SUCCEEDED(r))\n        {\n            lstrcpynW( &wfd.cFileName[0], path, MAX_PATH );\n            pidl = _ILCreateFromFindDataW( &wfd );\n        }\n        IFileSystemBindData_Release( fsbd );\n    }\n    IUnknown_Release( unk );\n\n    return pidl;\n}\n\n/**************************************************************************\n* IShellFolder_ParseDisplayName {SHELL32}\n*\n* Parse a display name.\n*\n* PARAMS\n*  hwndOwner       [in]  Parent window for any message's\n*  pbc             [in]  optional FileSystemBindData context\n*  lpszDisplayName [in]  Unicode displayname.\n*  pchEaten        [out] (unicode) characters processed\n*  ppidl           [out] complex pidl to item\n*  pdwAttributes   [out] items attributes\n*\n* NOTES\n*  Every folder tries to parse only its own (the leftmost) pidl and creates a\n*  subfolder to evaluate the remaining parts.\n*  Now we can parse into namespaces implemented by shell extensions\n*\n*  Behaviour on win98: lpszDisplayName=NULL -> crash\n*                      lpszDisplayName=\"\" -> returns mycomputer-pidl\n*\n* FIXME\n*    pdwAttributes is not set\n*    pchEaten is not set like in windows\n*/\nstatic HRESULT WINAPI\nIShellFolder_fnParseDisplayName (IShellFolder2 * iface,\n                                 HWND hwndOwner,\n                                 LPBC pbc,\n                                 LPOLESTR lpszDisplayName,\n                                 DWORD * pchEaten, LPITEMIDLIST * ppidl,\n                                 DWORD * pdwAttributes)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    HRESULT hr = S_OK;\n    LPCWSTR szNext = NULL;\n    WCHAR *p, szPath[MAX_PATH];\n    WIN32_FIND_DATAW find_data = { 0 };\n    IFileSystemBindData *fsbd = NULL;\n    LPITEMIDLIST pidlTemp = NULL;\n    DWORD len;\n\n    TRACE (\"(%p)->(HWND=%p,%p,%p=%s,%p,pidl=%p,%p)\\n\",\n     This, hwndOwner, pbc, lpszDisplayName, debugstr_w (lpszDisplayName),\n     pchEaten, ppidl, pdwAttributes);\n\n    if (!lpszDisplayName || !lpszDisplayName[0] || !ppidl) return E_INVALIDARG;\n\n    if (pchEaten)\n        *pchEaten = 0; /* strange but like the original */\n\n    if (pbc)\n    {\n        IUnknown *unk;\n\n        /* see if the caller bound File System Bind Data */\n        if (SUCCEEDED( IBindCtx_GetObjectParam( pbc, (WCHAR *)L\"File System Bind Data\", &unk )))\n        {\n            IUnknown_QueryInterface( unk, &IID_IFileSystemBindData, (void**)&fsbd );\n            IUnknown_Release( unk );\n        }\n    }\n\n    if (*lpszDisplayName)\n    {\n        /* build the full pathname to the element */\n        lstrcpynW(szPath, This->sPathTarget, MAX_PATH - 1);\n        PathAddBackslashW(szPath);\n        len = lstrlenW(szPath);\n        /* get the next element */\n        szNext = GetNextElementW( lpszDisplayName, szPath + len, MAX_PATH - len );\n\n        if (IsEqualCLSID( This->pclsid, &CLSID_UnixFolder ) && lpszDisplayName[0] == '/')\n        {\n            lstrcpynW( szPath + len, lpszDisplayName + 1, MAX_PATH - len );\n            for (p = szPath + len; *p; p++) if (*p == '/') *p = '\\\\';\n        }\n        else if (!wcsnicmp( lpszDisplayName, L\"\\\\\\\\?\\\\unix\\\\\", 9 ))\n        {\n            lstrcpynW( szPath + len, lpszDisplayName + 9, MAX_PATH - len );\n            if ((p = wcschr( szPath + len, '\\\\' )))\n                while (*p == '\\\\') *p++ = 0;\n            szNext = p;\n        }\n\n        /* Special case for the root folder. */\n        if (!wcsicmp( szPath, L\"\\\\\\\\?\\\\unix\\\\\" ))\n        {\n            *ppidl = SHAlloc(sizeof(USHORT));\n            if (!*ppidl) return E_FAIL;\n            (*ppidl)->mkid.cb = 0; /* Terminate the ITEMIDLIST */\n            return S_OK;\n        }\n\n        PathRemoveBackslashW( szPath );\n\n        if (szNext && *szNext)\n        {\n            hr = _ILCreateFromPathW( szPath, &pidlTemp );\n            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) && fsbd)\n            {\n                find_data.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;\n                lstrcpyW( find_data.cFileName, szPath + len );\n                pidlTemp = _ILCreateFromFindDataW( &find_data );\n            }\n            if (pidlTemp) /* try to analyse the next element */\n                hr = SHELL32_ParseNextElement( iface, hwndOwner, pbc, &pidlTemp,\n                                               (WCHAR *)szNext, pchEaten, pdwAttributes );\n        }\n        else  /* it's the last element */\n        {\n            if (fsbd)\n            {\n                if (FAILED( IFileSystemBindData_GetFindData( fsbd, &find_data )))\n                    find_data.dwFileAttributes = FILE_ATTRIBUTE_NORMAL;\n                lstrcpyW( find_data.cFileName, szPath + len );\n                pidlTemp = _ILCreateFromFindDataW( &find_data );\n            }\n            else hr = _ILCreateFromPathW(szPath, &pidlTemp);\n\n            if (pidlTemp && pdwAttributes && *pdwAttributes)\n                hr = SHELL32_GetItemAttributes(&This->IShellFolder2_iface, pidlTemp, pdwAttributes);\n        }\n    }\n\n    if (SUCCEEDED(hr))\n        *ppidl = pidlTemp;\n    else\n        *ppidl = NULL;\n\n    TRACE (\"(%p)->(-- pidl=%p ret=0x%08lx)\\n\", This, *ppidl, hr);\n\n    if (fsbd) IFileSystemBindData_Release( fsbd );\n    return hr;\n}\n\n/**************************************************************************\n* IShellFolder_fnEnumObjects\n* PARAMETERS\n*  HWND          hwndOwner,    //[in ] Parent Window\n*  DWORD         grfFlags,     //[in ] SHCONTF enumeration mask\n*  LPENUMIDLIST* ppenumIDList  //[out] IEnumIDList interface\n*/\nstatic HRESULT WINAPI\nIShellFolder_fnEnumObjects (IShellFolder2 * iface, HWND hwndOwner,\n                            DWORD dwFlags, LPENUMIDLIST * ppEnumIDList)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n    IEnumIDListImpl *list;\n\n    TRACE (\"(%p)->(HWND=%p flags=0x%08lx pplist=%p)\\n\", This, hwndOwner,\n     dwFlags, ppEnumIDList);\n\n    if (!(list = IEnumIDList_Constructor()))\n        return E_OUTOFMEMORY;\n    CreateFolderEnumList(list, This->sPathTarget, dwFlags);\n    *ppEnumIDList = &list->IEnumIDList_iface;\n\n    TRACE (\"-- (%p)->(new ID List: %p)\\n\", This, *ppEnumIDList);\n\n    return S_OK;\n}\n\n/**************************************************************************\n* IShellFolder_fnBindToObject\n* PARAMETERS\n*  LPCITEMIDLIST pidl,       //[in ] relative pidl to open\n*  LPBC          pbc,        //[in ] optional FileSystemBindData context\n*  REFIID        riid,       //[in ] Initial Interface\n*  LPVOID*       ppvObject   //[out] Interface*\n*/\nstatic HRESULT WINAPI\nIShellFolder_fnBindToObject (IShellFolder2 * iface, LPCITEMIDLIST pidl,\n                             LPBC pbc, REFIID riid, LPVOID * ppvOut)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n    const CLSID *clsid = This->pclsid;\n\n    TRACE (\"(%p)->(pidl=%p,%p,%s,%p)\\n\", This, pidl, pbc,\n     shdebugstr_guid (riid), ppvOut);\n\n    if (!IsEqualCLSID( clsid, &CLSID_UnixFolder ) && !IsEqualCLSID( clsid, &CLSID_UnixDosFolder ))\n        clsid = &CLSID_ShellFSFolder;\n\n    return SHELL32_BindToChild (This->pidlRoot, clsid, This->sPathTarget, pidl, riid, ppvOut);\n}\n\n/**************************************************************************\n*  IShellFolder_fnBindToStorage\n* PARAMETERS\n*  LPCITEMIDLIST pidl,       //[in ] complex pidl to store\n*  LPBC          pbc,        //[in ] reserved\n*  REFIID        riid,       //[in ] Initial storage interface\n*  LPVOID*       ppvObject   //[out] Interface* returned\n*/\nstatic HRESULT WINAPI\nIShellFolder_fnBindToStorage (IShellFolder2 * iface, LPCITEMIDLIST pidl,\n                              LPBC pbcReserved, REFIID riid, LPVOID * ppvOut)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    FIXME (\"(%p)->(pidl=%p,%p,%s,%p) stub\\n\", This, pidl, pbcReserved,\n     shdebugstr_guid (riid), ppvOut);\n\n    *ppvOut = NULL;\n    return E_NOTIMPL;\n}\n\n/**************************************************************************\n*  IShellFolder_fnCompareIDs\n*/\n\nstatic HRESULT WINAPI\nIShellFolder_fnCompareIDs (IShellFolder2 * iface, LPARAM lParam,\n                           LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    int nReturn;\n\n    TRACE (\"(%p)->(0x%08Ix,pidl1=%p,pidl2=%p)\\n\", This, lParam, pidl1, pidl2);\n    nReturn = SHELL32_CompareIDs(&This->IShellFolder2_iface, lParam, pidl1, pidl2);\n    TRACE (\"-- %i\\n\", nReturn);\n    return nReturn;\n}\n\n/**************************************************************************\n* IShellFolder_fnCreateViewObject\n*/\nstatic HRESULT WINAPI\nIShellFolder_fnCreateViewObject (IShellFolder2 * iface, HWND hwndOwner,\n                                 REFIID riid, LPVOID * ppvOut)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    LPSHELLVIEW pShellView;\n    HRESULT hr = E_INVALIDARG;\n\n    TRACE (\"(%p)->(hwnd=%p,%s,%p)\\n\", This, hwndOwner, shdebugstr_guid (riid),\n     ppvOut);\n\n    if (ppvOut) {\n        *ppvOut = NULL;\n\n        if (IsEqualIID (riid, &IID_IDropTarget)) {\n            hr = IShellFolder2_QueryInterface (iface, &IID_IDropTarget, ppvOut);\n        } else if (IsEqualIID (riid, &IID_IContextMenu)) {\n            hr = BackgroundMenu_Constructor((IShellFolder*)iface, FALSE, riid, ppvOut);\n        } else if (IsEqualIID (riid, &IID_IShellView)) {\n            pShellView = IShellView_Constructor ((IShellFolder *) iface);\n            if (pShellView) {\n                hr = IShellView_QueryInterface (pShellView, riid, ppvOut);\n                IShellView_Release (pShellView);\n            }\n        }\n    }\n    TRACE (\"-- (%p)->(interface=%p)\\n\", This, ppvOut);\n    return hr;\n}\n\n/**************************************************************************\n*  IShellFolder_fnGetAttributesOf\n*\n* PARAMETERS\n*  UINT            cidl,     //[in ] num elements in pidl array\n*  LPCITEMIDLIST*  apidl,    //[in ] simple pidl array\n*  ULONG*          rgfInOut) //[out] result array\n*\n*/\nstatic HRESULT WINAPI\nIShellFolder_fnGetAttributesOf (IShellFolder2 * iface, UINT cidl,\n                                LPCITEMIDLIST * apidl, DWORD * rgfInOut)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    HRESULT hr = S_OK;\n\n    TRACE (\"(%p)->(cidl=%d apidl=%p mask=%p (0x%08lx))\\n\", This, cidl, apidl,\n     rgfInOut, rgfInOut ? *rgfInOut : 0);\n\n    if (!rgfInOut)\n        return E_INVALIDARG;\n    if (cidl && !apidl)\n        return E_INVALIDARG;\n\n    if (*rgfInOut == 0)\n        *rgfInOut = ~0;\n\n    if(cidl == 0){\n        IShellFolder2 *parent = NULL;\n        LPCITEMIDLIST rpidl = NULL;\n\n        if (_ILIsSpecialFolder(This->pidlRoot))\n        {\n            *rgfInOut &= (SFGAO_HASSUBFOLDER | SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_FILESYSANCESTOR |\n                          SFGAO_DROPTARGET | SFGAO_HASPROPSHEET | SFGAO_CANRENAME);\n        }\n        else\n        {\n            hr = SHBindToParent(This->pidlRoot, &IID_IShellFolder2, (void **)&parent, &rpidl);\n            if(SUCCEEDED(hr)) {\n                SHELL32_GetItemAttributes(parent, rpidl, rgfInOut);\n                IShellFolder2_Release(parent);\n            }\n        }\n    }\n    else {\n        while (cidl > 0 && *apidl) {\n            pdump (*apidl);\n            SHELL32_GetItemAttributes(&This->IShellFolder2_iface, *apidl, rgfInOut);\n            apidl++;\n            cidl--;\n        }\n    }\n    /* make sure SFGAO_VALIDATE is cleared, some apps depend on that */\n    *rgfInOut &= ~SFGAO_VALIDATE;\n\n    TRACE (\"-- result=0x%08lx\\n\", *rgfInOut);\n\n    return hr;\n}\n\n/**************************************************************************\n * SHELL32_CreateExtensionUIObject (internal)\n */\nstatic HRESULT SHELL32_CreateExtensionUIObject(IShellFolder2 *iface,\n        LPCITEMIDLIST pidl, REFIID riid, LPVOID *ppvOut)\n{\n    IPersistFile *persist_file;\n    char extensionA[20];\n    WCHAR extensionW[20], buf[MAX_PATH];\n    DWORD size = MAX_PATH;\n    STRRET path;\n    WCHAR *file;\n    GUID guid;\n    HKEY key;\n    HRESULT hr;\n\n\n    if(!_ILGetExtension(pidl, extensionA, 20))\n        return S_FALSE;\n\n    MultiByteToWideChar(CP_ACP, 0, extensionA, -1, extensionW, 20);\n\n    swprintf(buf, ARRAY_SIZE(buf), L\".%s\\\\ShellEx\\\\{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\",\n             extensionW, riid->Data1, riid->Data2, riid->Data3,\n            riid->Data4[0], riid->Data4[1], riid->Data4[2], riid->Data4[3],\n            riid->Data4[4], riid->Data4[5], riid->Data4[6], riid->Data4[7]);\n\n    if(RegGetValueW(HKEY_CLASSES_ROOT, buf, NULL, RRF_RT_REG_SZ,\n                NULL, buf, &size) != ERROR_SUCCESS)\n        return S_FALSE;\n\n    if(RegCreateKeyExW(HKEY_LOCAL_MACHINE, L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Shell Extensions\\\\Blocked\", 0, 0, 0,\n                KEY_READ, NULL, &key, NULL) != ERROR_SUCCESS)\n        return E_FAIL;\n    if(RegQueryValueExW(key, buf, 0, NULL, NULL, NULL)\n            != ERROR_FILE_NOT_FOUND)\n        return E_ACCESSDENIED;\n    RegCloseKey(key);\n\n    if(RegCreateKeyExW(HKEY_CURRENT_USER, L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Shell Extensions\\\\Blocked\", 0, 0, 0,\n                KEY_READ, NULL, &key, NULL) != ERROR_SUCCESS)\n        return E_FAIL;\n    if(RegQueryValueExW(key, buf, 0, NULL, NULL, NULL)\n            != ERROR_FILE_NOT_FOUND)\n        return E_ACCESSDENIED;\n    RegCloseKey(key);\n\n    if(!GUIDFromStringW(buf, &guid))\n        return E_FAIL;\n\n    hr = CoCreateInstance(&guid, NULL, CLSCTX_INPROC_SERVER,\n            &IID_IPersistFile, (void**)&persist_file);\n    if(FAILED(hr))\n        return hr;\n\n    hr = IShellFolder2_GetDisplayNameOf(iface, pidl, SHGDN_FORPARSING, &path);\n    if(SUCCEEDED(hr))\n        hr = StrRetToStrW(&path, NULL, &file);\n    if(FAILED(hr)) {\n        IPersistFile_Release(persist_file);\n        return hr;\n    }\n\n    hr = IPersistFile_Load(persist_file, file, STGM_READ);\n    CoTaskMemFree(file);\n    if(FAILED(hr)) {\n        IPersistFile_Release(persist_file);\n        return hr;\n    }\n\n    hr = IPersistFile_QueryInterface(persist_file, riid, ppvOut);\n    IPersistFile_Release(persist_file);\n    return hr;\n}\n\n/**************************************************************************\n*  IShellFolder_fnGetUIObjectOf\n*\n* PARAMETERS\n*  HWND           hwndOwner, //[in ] Parent window for any output\n*  UINT           cidl,      //[in ] array size\n*  LPCITEMIDLIST* apidl,     //[in ] simple pidl array\n*  REFIID         riid,      //[in ] Requested Interface\n*  UINT*          prgfInOut, //[   ] reserved\n*  LPVOID*        ppvObject) //[out] Resulting Interface\n*\n* NOTES\n*  This function gets asked to return \"view objects\" for one or more (multiple\n*  select) items:\n*  The viewobject typically is an COM object with one of the following\n*  interfaces:\n*  IExtractIcon,IDataObject,IContextMenu\n*  In order to support icon positions in the default Listview your DataObject\n*  must implement the SetData method (in addition to GetData :) - the shell\n*  passes a barely documented \"Icon positions\" structure to SetData when the\n*  drag starts, and GetData's it if the drop is in another explorer window that\n*  needs the positions.\n*/\nstatic HRESULT WINAPI\nIShellFolder_fnGetUIObjectOf (IShellFolder2 * iface,\n                              HWND hwndOwner,\n                              UINT cidl, LPCITEMIDLIST * apidl, REFIID riid,\n                              UINT * prgfInOut, LPVOID * ppvOut)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    LPITEMIDLIST pidl;\n    IUnknown *pObj = NULL;\n    HRESULT hr = E_INVALIDARG;\n\n    TRACE (\"(%p)->(%p,%u,apidl=%p,%s,%p,%p)\\n\",\n     This, hwndOwner, cidl, apidl, shdebugstr_guid (riid), prgfInOut, ppvOut);\n\n    if (ppvOut) {\n        *ppvOut = NULL;\n\n        if(cidl == 1) {\n            hr = SHELL32_CreateExtensionUIObject(iface, *apidl, riid, ppvOut);\n            if(hr != S_FALSE)\n                return hr;\n        }\n\n        if (IsEqualIID (riid, &IID_IContextMenu) && (cidl >= 1)) {\n            return ItemMenu_Constructor((IShellFolder*)iface, This->pidlRoot, apidl, cidl, riid, ppvOut);\n        } else if (IsEqualIID (riid, &IID_IDataObject) && (cidl >= 1)) {\n            pObj = (LPUNKNOWN) IDataObject_Constructor (hwndOwner,\n             This->pidlRoot, apidl, cidl);\n            hr = S_OK;\n        } else if (IsEqualIID (riid, &IID_IExtractIconA) && (cidl == 1)) {\n            pidl = ILCombine (This->pidlRoot, apidl[0]);\n            pObj = (LPUNKNOWN) IExtractIconA_Constructor (pidl);\n            SHFree (pidl);\n            hr = S_OK;\n        } else if (IsEqualIID (riid, &IID_IExtractIconW) && (cidl == 1)) {\n            pidl = ILCombine (This->pidlRoot, apidl[0]);\n            pObj = (LPUNKNOWN) IExtractIconW_Constructor (pidl);\n            SHFree (pidl);\n            hr = S_OK;\n        } else if (IsEqualIID (riid, &IID_IDropTarget) && (cidl >= 1)) {\n            hr = IShellFolder2_QueryInterface (iface, &IID_IDropTarget,\n             (LPVOID *) & pObj);\n        } else if ((IsEqualIID(riid,&IID_IShellLinkW) ||\n         IsEqualIID(riid,&IID_IShellLinkA)) && (cidl == 1)) {\n            pidl = ILCombine (This->pidlRoot, apidl[0]);\n            hr = IShellLink_ConstructFromFile(NULL, riid, pidl, &pObj);\n            SHFree (pidl);\n        } else {\n            hr = E_NOINTERFACE;\n        }\n\n        if (SUCCEEDED(hr) && !pObj)\n            hr = E_OUTOFMEMORY;\n\n        *ppvOut = pObj;\n    }\n    TRACE (\"(%p)->hr=0x%08lx\\n\", This, hr);\n    return hr;\n}\n\n/******************************************************************************\n * SHELL_FS_HideExtension [Internal]\n *\n * Query the registry if the filename extension of a given path should be \n * hidden.\n *\n * PARAMS\n *  szPath [I] Relative or absolute path of a file\n *  \n * RETURNS\n *  TRUE, if the filename's extension should be hidden\n *  FALSE, otherwise.\n */\nstatic BOOL SHELL_FS_HideExtension(LPCWSTR szPath)\n{\n    HKEY hKey;\n    DWORD dwData;\n    DWORD dwDataSize = sizeof (DWORD);\n    BOOL doHide = FALSE; /* The default value is FALSE (win98 at least) */\n\n    if (!RegCreateKeyExW(HKEY_CURRENT_USER, L\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Advanced\",\n                         0, 0, 0, KEY_ALL_ACCESS, 0, &hKey, 0)) {\n        if (!RegQueryValueExW(hKey, L\"HideFileExt\", 0, 0, (LPBYTE) &dwData, &dwDataSize))\n            doHide = dwData;\n        RegCloseKey (hKey);\n    }\n\n    if (!doHide) {\n        LPWSTR ext = PathFindExtensionW(szPath);\n\n        if (*ext != '\\0') {\n            WCHAR classname[MAX_PATH];\n            LONG classlen = sizeof(classname);\n\n            if (!RegQueryValueW(HKEY_CLASSES_ROOT, ext, classname, &classlen))\n                if (!RegOpenKeyW(HKEY_CLASSES_ROOT, classname, &hKey)) {\n                    if (!RegQueryValueExW(hKey, L\"NeverShowExt\", 0, NULL, NULL, NULL))\n                        doHide = TRUE;\n                    RegCloseKey(hKey);\n                }\n        }\n    }\n    return doHide;\n}\n    \nvoid SHELL_FS_ProcessDisplayFilename(LPWSTR szPath, DWORD dwFlags)\n{\n    /*FIXME: MSDN also mentions SHGDN_FOREDITING which is not yet handled. */\n    if (!(dwFlags & SHGDN_FORPARSING) &&\n        ((dwFlags & SHGDN_INFOLDER) || (dwFlags == SHGDN_NORMAL))) {\n        if (SHELL_FS_HideExtension(szPath) && szPath[0] != '.')\n            PathRemoveExtensionW(szPath);\n    }\n}\n\nstatic void get_display_name( WCHAR dest[MAX_PATH], const WCHAR *path, LPCITEMIDLIST pidl, BOOL is_unix )\n{\n    char *buffer;\n    WCHAR *res;\n    DWORD i, len;\n\n    lstrcpynW( dest, path, MAX_PATH );\n\n    /* try to get a better path than the \\\\?\\unix one */\n    if (!wcsnicmp( path, L\"\\\\\\\\?\\\\unix\\\\\", 9 ))\n    {\n        if (!is_unix)\n        {\n            len = WideCharToMultiByte( CP_UNIXCP, 0, path + 8, -1, NULL, 0, NULL, NULL );\n            buffer = heap_alloc( len );\n            len = WideCharToMultiByte( CP_UNIXCP, 0, path + 8, -1, buffer, len, NULL, NULL );\n            for (i = 0; i < len; i++) if (buffer[i] == '\\\\') buffer[i] = '/';\n            if ((res = wine_get_dos_file_name( buffer )))\n            {\n                lstrcpynW( dest, res, MAX_PATH );\n                heap_free( res );\n            }\n        }\n        else lstrcpynW( dest, path + 8, MAX_PATH );\n    }\n\n    if (!_ILIsDesktop(pidl))\n    {\n        PathAddBackslashW( dest );\n        len = lstrlenW( dest );\n        _ILSimpleGetTextW( pidl, dest + len, MAX_PATH - len );\n    }\n    if (is_unix) for (i = 0; dest[i]; i++) if (dest[i] == '\\\\') dest[i] = '/';\n}\n\n/**************************************************************************\n*  IShellFolder_fnGetDisplayNameOf\n*  Retrieves the display name for the specified file object or subfolder\n*\n* PARAMETERS\n*  LPCITEMIDLIST pidl,    //[in ] complex pidl to item\n*  DWORD         dwFlags, //[in ] SHGNO formatting flags\n*  LPSTRRET      lpName)  //[out] Returned display name\n*\n* FIXME\n*  if the name is in the pidl the ret value should be a STRRET_OFFSET\n*/\n\nstatic HRESULT WINAPI\nIShellFolder_fnGetDisplayNameOf (IShellFolder2 * iface, LPCITEMIDLIST pidl,\n                                 DWORD dwFlags, LPSTRRET strRet)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n    LPWSTR pszPath;\n\n    HRESULT hr = S_OK;\n\n    TRACE (\"(%p)->(pidl=%p,0x%08lx,%p)\\n\", This, pidl, dwFlags, strRet);\n    pdump (pidl);\n\n    if (!strRet)\n        return E_INVALIDARG;\n\n    pszPath = CoTaskMemAlloc((MAX_PATH +1) * sizeof(WCHAR));\n    if (!pszPath)\n        return E_OUTOFMEMORY;\n\n    if (_ILIsDesktop(pidl)) { /* empty pidl */\n        if ((GET_SHGDN_FOR(dwFlags) & SHGDN_FORPARSING) &&\n            (GET_SHGDN_RELATION(dwFlags) != SHGDN_INFOLDER))\n        {\n            if (This->sPathTarget)\n                get_display_name( pszPath, This->sPathTarget, pidl,\n                                  IsEqualCLSID( This->pclsid, &CLSID_UnixFolder ));\n        } else {\n            /* pidl has to contain exactly one non null SHITEMID */\n            hr = E_INVALIDARG;\n        }\n    } else if (_ILIsPidlSimple(pidl)) {\n        if ((GET_SHGDN_FOR(dwFlags) & SHGDN_FORPARSING) &&\n            (GET_SHGDN_RELATION(dwFlags) != SHGDN_INFOLDER) &&\n            This->sPathTarget)\n        {\n            get_display_name( pszPath, This->sPathTarget, pidl,\n                              IsEqualCLSID( This->pclsid, &CLSID_UnixFolder ));\n        }\n        else _ILSimpleGetTextW(pidl, pszPath, MAX_PATH);\n        if (!_ILIsFolder(pidl)) SHELL_FS_ProcessDisplayFilename(pszPath, dwFlags);\n    } else {\n        hr = SHELL32_GetDisplayNameOfChild(iface, pidl, dwFlags, pszPath, MAX_PATH);\n    }\n\n    if (SUCCEEDED(hr)) {\n        /* Win9x always returns ANSI strings, NT always returns Unicode strings */\n        if (GetVersion() & 0x80000000) {\n            strRet->uType = STRRET_CSTR;\n            if (!WideCharToMultiByte(CP_ACP, 0, pszPath, -1, strRet->u.cStr, MAX_PATH,\n                 NULL, NULL))\n                strRet->u.cStr[0] = '\\0';\n            CoTaskMemFree(pszPath);\n        } else {\n            strRet->uType = STRRET_WSTR;\n            strRet->u.pOleStr = pszPath;\n        }\n    } else\n        CoTaskMemFree(pszPath);\n\n    TRACE (\"-- (%p)->(%s)\\n\", This, strRet->uType == STRRET_CSTR ? strRet->u.cStr : debugstr_w(strRet->u.pOleStr));\n    return hr;\n}\n\n/**************************************************************************\n*  IShellFolder_fnSetNameOf\n*  Changes the name of a file object or subfolder, possibly changing its item\n*  identifier in the process.\n*\n* PARAMETERS\n*  HWND          hwndOwner,  //[in ] Owner window for output\n*  LPCITEMIDLIST pidl,       //[in ] simple pidl of item to change\n*  LPCOLESTR     lpszName,   //[in ] the items new display name\n*  DWORD         dwFlags,    //[in ] SHGNO formatting flags\n*  LPITEMIDLIST* ppidlOut)   //[out] simple pidl returned\n*/\nstatic HRESULT WINAPI IShellFolder_fnSetNameOf (IShellFolder2 * iface,\n                                                HWND hwndOwner,\n                                                LPCITEMIDLIST pidl,\n                                                LPCOLESTR lpName,\n                                                DWORD dwFlags,\n                                                LPITEMIDLIST * pPidlOut)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n    WCHAR szSrc[MAX_PATH + 1], szDest[MAX_PATH + 1];\n    LPWSTR ptr;\n    BOOL bIsFolder = _ILIsFolder (ILFindLastID (pidl));\n\n    TRACE (\"(%p)->(%p,pidl=%p,%s,%lu,%p)\\n\", This, hwndOwner, pidl,\n     debugstr_w (lpName), dwFlags, pPidlOut);\n\n    /* pidl has to contain a single non-empty SHITEMID */\n    if (_ILIsDesktop(pidl) || !_ILIsPidlSimple(pidl) || !_ILGetTextPointer(pidl)) return E_INVALIDARG;\n\n    if (wcspbrk( lpName, L\"\\\\/:*?\\\"<>|\" )) return HRESULT_FROM_WIN32(ERROR_CANCELLED);\n\n    /* build source path */\n    lstrcpynW(szSrc, This->sPathTarget, MAX_PATH);\n    ptr = PathAddBackslashW (szSrc);\n    _ILSimpleGetTextW (pidl, ptr, MAX_PATH + 1 - (ptr - szSrc));\n\n    /* build destination path */\n    lstrcpynW(szDest, This->sPathTarget, MAX_PATH);\n    ptr = PathAddBackslashW (szDest);\n    lstrcpynW(ptr, lpName, MAX_PATH + 1 - (ptr - szDest));\n\n    if(!(dwFlags & SHGDN_FORPARSING) && SHELL_FS_HideExtension(szSrc)) {\n        WCHAR *ext = PathFindExtensionW(szSrc);\n        if(*ext != '\\0') {\n            INT len = lstrlenW(szDest);\n            lstrcpynW(szDest + len, ext, MAX_PATH - len);\n        }\n    }\n    \n    TRACE (\"src=%s dest=%s\\n\", debugstr_w(szSrc), debugstr_w(szDest));\n\n    if (MoveFileW (szSrc, szDest)) {\n        HRESULT hr = S_OK;\n\n        if (pPidlOut)\n            hr = _ILCreateFromPathW(szDest, pPidlOut);\n\n        SHChangeNotify (bIsFolder ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM,\n         SHCNF_PATHW, szSrc, szDest);\n\n        return hr;\n    }\n\n    return E_FAIL;\n}\n\nstatic HRESULT WINAPI IShellFolder_fnGetDefaultSearchGUID(IShellFolder2 *iface, GUID *guid)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n    TRACE(\"(%p)->(%p)\\n\", This, guid);\n    return E_NOTIMPL;\n}\n\nstatic HRESULT WINAPI IShellFolder_fnEnumSearches (IShellFolder2 * iface,\n                                                   IEnumExtraSearch ** ppenum)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n    FIXME (\"(%p)\\n\", This);\n    return E_NOTIMPL;\n}\n\nstatic HRESULT WINAPI\nIShellFolder_fnGetDefaultColumn(IShellFolder2 *iface, DWORD reserved, ULONG *sort, ULONG *display)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE(\"(%p)->(%#lx, %p, %p)\\n\", This, reserved, sort, display);\n\n    return E_NOTIMPL;\n}\n\nstatic HRESULT WINAPI\nIShellFolder_fnGetDefaultColumnState (IShellFolder2 * iface, UINT iColumn,\n                                      DWORD * pcsFlags)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE (\"(%p)\\n\", This);\n\n    if (!pcsFlags || iColumn >= GENERICSHELLVIEWCOLUMNS)\n        return E_INVALIDARG;\n\n    *pcsFlags = GenericSFHeader[iColumn].pcsFlags;\n\n    return S_OK;\n}\n\nstatic HRESULT WINAPI\nIShellFolder_fnGetDetailsEx (IShellFolder2 * iface, LPCITEMIDLIST pidl,\n                             const SHCOLUMNID * pscid, VARIANT * pv)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n    FIXME (\"(%p)\\n\", This);\n\n    return E_NOTIMPL;\n}\n\nstatic HRESULT WINAPI\nIShellFolder_fnGetDetailsOf (IShellFolder2 * iface, LPCITEMIDLIST pidl,\n                             UINT iColumn, SHELLDETAILS * psd)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE (\"(%p)->(%p %i %p)\\n\", This, pidl, iColumn, psd);\n\n    if (!psd || iColumn >= GENERICSHELLVIEWCOLUMNS)\n        return E_INVALIDARG;\n\n    if (!pidl) return SHELL32_GetColumnDetails(GenericSFHeader, iColumn, psd);\n\n    return shellfolder_get_file_details( iface, pidl, GenericSFHeader, iColumn, psd );\n}\n\nstatic HRESULT WINAPI\nIShellFolder_fnMapColumnToSCID (IShellFolder2 *iface, UINT column, SHCOLUMNID *scid)\n{\n    IGenericSFImpl *This = impl_from_IShellFolder2(iface);\n\n    TRACE(\"(%p)->(%u %p)\\n\", This, column, scid);\n\n    if (column >= GENERICSHELLVIEWCOLUMNS)\n        return E_INVALIDARG;\n\n    return shellfolder_map_column_to_scid(GenericSFHeader, column, scid);\n}\n\nstatic const IShellFolder2Vtbl sfvt =\n{\n    IShellFolder_fnQueryInterface,\n    IShellFolder_fnAddRef,\n    IShellFolder_fnRelease,\n    IShellFolder_fnParseDisplayName,\n    IShellFolder_fnEnumObjects,\n    IShellFolder_fnBindToObject,\n    IShellFolder_fnBindToStorage,\n    IShellFolder_fnCompareIDs,\n    IShellFolder_fnCreateViewObject,\n    IShellFolder_fnGetAttributesOf,\n    IShellFolder_fnGetUIObjectOf,\n    IShellFolder_fnGetDisplayNameOf,\n    IShellFolder_fnSetNameOf,\n    /* ShellFolder2 */\n    IShellFolder_fnGetDefaultSearchGUID,\n    IShellFolder_fnEnumSearches,\n    IShellFolder_fnGetDefaultColumn,\n    IShellFolder_fnGetDefaultColumnState,\n    IShellFolder_fnGetDetailsEx,\n    IShellFolder_fnGetDetailsOf,\n    IShellFolder_fnMapColumnToSCID\n};\n\n/****************************************************************************\n * ISFHelper for IShellFolder implementation\n */\n\nstatic HRESULT WINAPI ISFHelper_fnQueryInterface(ISFHelper *iface, REFIID riid, void **ppvObj)\n{\n    IGenericSFImpl *This = impl_from_ISFHelper(iface);\n\n    return IUnknown_QueryInterface(This->outer_unk, riid, ppvObj);\n}\n\nstatic ULONG WINAPI ISFHelper_fnAddRef(ISFHelper *iface)\n{\n    IGenericSFImpl *This = impl_from_ISFHelper(iface);\n\n    return IUnknown_AddRef(This->outer_unk);\n}\n\nstatic ULONG WINAPI ISFHelper_fnRelease(ISFHelper *iface)\n{\n    IGenericSFImpl *This = impl_from_ISFHelper(iface);\n\n    return IUnknown_Release(This->outer_unk);\n}\n\n/****************************************************************************\n * ISFHelper_fnGetUniqueName\n *\n * creates a unique folder name\n */\n\nstatic HRESULT WINAPI\nISFHelper_fnGetUniqueName (ISFHelper * iface, LPWSTR pwszName, UINT uLen)\n{\n    IGenericSFImpl *This = impl_from_ISFHelper(iface);\n    IEnumIDList *penum;\n    HRESULT hr;\n    WCHAR wszText[MAX_PATH];\n    WCHAR wszNewFolder[25];\n\n    TRACE (\"(%p)(%p %u)\\n\", This, pwszName, uLen);\n\n    LoadStringW(shell32_hInstance, IDS_NEWFOLDER, wszNewFolder, ARRAY_SIZE(wszNewFolder));\n    if (uLen < ARRAY_SIZE(wszNewFolder) + 3)\n        return E_POINTER;\n\n    lstrcpynW (pwszName, wszNewFolder, uLen);\n\n    hr = IShellFolder2_EnumObjects(&This->IShellFolder2_iface, 0,\n            SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &penum);\n    if (penum) {\n        LPITEMIDLIST pidl;\n        DWORD dwFetched;\n        int i = 1;\n\nnext:\n        IEnumIDList_Reset (penum);\n        while (S_OK == IEnumIDList_Next (penum, 1, &pidl, &dwFetched) &&\n         dwFetched) {\n            _ILSimpleGetTextW (pidl, wszText, MAX_PATH);\n            if (0 == lstrcmpiW (wszText, pwszName)) {\n                swprintf (pwszName, uLen, L\"%s %d\", wszNewFolder, i++);\n                if (i > 99) {\n                    hr = E_FAIL;\n                    break;\n                }\n                goto next;\n            }\n        }\n\n        IEnumIDList_Release (penum);\n    }\n    return hr;\n}\n\n/****************************************************************************\n * ISFHelper_fnAddFolder\n *\n * adds a new folder.\n */\n\nstatic HRESULT WINAPI\nISFHelper_fnAddFolder (ISFHelper * iface, HWND hwnd, LPCWSTR pwszName,\n                       LPITEMIDLIST * ppidlOut)\n{\n    IGenericSFImpl *This = impl_from_ISFHelper(iface);\n    WCHAR wszNewDir[MAX_PATH];\n    BOOL bRes;\n    HRESULT hres = E_FAIL;\n\n    TRACE (\"(%p)(%s %p)\\n\", This, debugstr_w(pwszName), ppidlOut);\n\n    wszNewDir[0] = 0;\n    if (This->sPathTarget)\n        lstrcpynW(wszNewDir, This->sPathTarget, MAX_PATH);\n    PathAppendW(wszNewDir, pwszName);\n\n    bRes = CreateDirectoryW (wszNewDir, NULL);\n    if (bRes) {\n        LPITEMIDLIST relPidl;\n\n        lstrcpyW(wszNewDir, pwszName);\n\n        hres = IShellFolder2_ParseDisplayName(&This->IShellFolder2_iface, hwnd, NULL, wszNewDir,\n                NULL, &relPidl, NULL);\n\n        if (SUCCEEDED(hres)) {\n            LPITEMIDLIST fullPidl;\n\n            fullPidl = ILCombine(This->pidlRoot, relPidl);\n\n            if (fullPidl) {\n                SHChangeNotify(SHCNE_MKDIR, SHCNF_IDLIST, fullPidl, NULL);\n                ILFree(fullPidl);\n\n                if (ppidlOut)\n                    *ppidlOut = relPidl;\n                else\n                    ILFree(relPidl);\n            } else {\n                WARN(\"failed to combine %s into a full PIDL\\n\", wine_dbgstr_w(pwszName));\n                ILFree(relPidl);\n            }\n\n        } else\n            WARN(\"failed to parse %s into a PIDL\\n\", wine_dbgstr_w(pwszName));\n\n    } else {\n        WCHAR wszText[128 + MAX_PATH];\n        WCHAR wszTempText[128];\n        WCHAR wszCaption[256];\n\n        /* Cannot Create folder because of permissions */\n        LoadStringW (shell32_hInstance, IDS_CREATEFOLDER_DENIED, wszTempText, ARRAY_SIZE(wszTempText));\n        LoadStringW (shell32_hInstance, IDS_CREATEFOLDER_CAPTION, wszCaption, ARRAY_SIZE(wszCaption));\n        swprintf (wszText, ARRAY_SIZE(wszText), wszTempText, wszNewDir);\n        MessageBoxW (hwnd, wszText, wszCaption, MB_OK | MB_ICONEXCLAMATION);\n    }\n\n    return hres;\n}\n\n/****************************************************************************\n * build_paths_list\n *\n * Builds a list of paths like the one used in SHFileOperation from a table of\n * PIDLs relative to the given base folder\n */\nstatic WCHAR *build_paths_list(LPCWSTR wszBasePath, int cidl, const LPCITEMIDLIST *pidls)\n{\n    WCHAR *wszPathsList;\n    WCHAR *wszListPos;\n    int iPathLen;\n    int i;\n    \n    iPathLen = lstrlenW(wszBasePath);\n    wszPathsList = heap_alloc(MAX_PATH*sizeof(WCHAR)*cidl+1);\n    wszListPos = wszPathsList;\n    \n    for (i = 0; i < cidl; i++) {\n        if (!_ILIsFolder(pidls[i]) && !_ILIsValue(pidls[i]))\n            continue;\n\n        lstrcpynW(wszListPos, wszBasePath, MAX_PATH);\n        /* FIXME: abort if path too long */\n        _ILSimpleGetTextW(pidls[i], wszListPos+iPathLen, MAX_PATH-iPathLen);\n        wszListPos += lstrlenW(wszListPos)+1;\n    }\n    *wszListPos=0;\n    return wszPathsList;\n}\n\n/****************************************************************************\n * ISFHelper_fnDeleteItems\n *\n * deletes items in folder\n */\nstatic HRESULT WINAPI\nISFHelper_fnDeleteItems (ISFHelper * iface, UINT cidl, LPCITEMIDLIST * apidl)\n{\n    IGenericSFImpl *This = impl_from_ISFHelper(iface);\n    UINT i;\n    SHFILEOPSTRUCTW op;\n    WCHAR wszPath[MAX_PATH];\n    WCHAR *wszPathsList;\n    HRESULT ret;\n    WCHAR *wszCurrentPath;\n\n    TRACE (\"(%p)(%u %p)\\n\", This, cidl, apidl);\n    if (cidl==0) return S_OK;\n\n    if (This->sPathTarget)\n        lstrcpynW(wszPath, This->sPathTarget, MAX_PATH);\n    else\n        wszPath[0] = '\\0';\n    PathAddBackslashW(wszPath);\n    wszPathsList = build_paths_list(wszPath, cidl, apidl);\n\n    ZeroMemory(&op, sizeof(op));\n    op.hwnd = GetActiveWindow();\n    op.wFunc = FO_DELETE;\n    op.pFrom = wszPathsList;\n    op.fFlags = FOF_ALLOWUNDO;\n    if (SHFileOperationW(&op))\n    {\n        WARN(\"SHFileOperation failed\\n\");\n        ret = E_FAIL;\n    }\n    else\n        ret = S_OK;\n\n    /* we currently need to manually send the notifies */\n    wszCurrentPath = wszPathsList;\n    for (i = 0; i < cidl; i++)\n    {\n        LONG wEventId;\n\n        if (_ILIsFolder(apidl[i]))\n            wEventId = SHCNE_RMDIR;\n        else if (_ILIsValue(apidl[i]))\n            wEventId = SHCNE_DELETE;\n        else\n            continue;\n\n        /* check if file exists */\n        if (GetFileAttributesW(wszCurrentPath) == INVALID_FILE_ATTRIBUTES)\n        {\n            LPITEMIDLIST pidl = ILCombine(This->pidlRoot, apidl[i]);\n            SHChangeNotify(wEventId, SHCNF_IDLIST, pidl, NULL);\n            SHFree(pidl);\n        }\n\n        wszCurrentPath += lstrlenW(wszCurrentPath)+1;\n    }\n    heap_free(wszPathsList);\n    return ret;\n}\n\n/****************************************************************************\n * ISFHelper_fnCopyItems\n *\n * copies items to this folder\n */\nstatic HRESULT WINAPI\nISFHelper_fnCopyItems (ISFHelper * iface, IShellFolder * pSFFrom, UINT cidl,\n                       LPCITEMIDLIST * apidl)\n{\n    HRESULT ret=E_FAIL;\n    IPersistFolder2 *ppf2 = NULL;\n    WCHAR wszSrcPathRoot[MAX_PATH],\n      wszDstPath[MAX_PATH+1];\n    WCHAR *wszSrcPathsList;\n    IGenericSFImpl *This = impl_from_ISFHelper(iface);\n\n    SHFILEOPSTRUCTW fop;\n\n    TRACE (\"(%p)->(%p,%u,%p)\\n\", This, pSFFrom, cidl, apidl);\n\n    IShellFolder_QueryInterface (pSFFrom, &IID_IPersistFolder2,\n     (LPVOID *) & ppf2);\n    if (ppf2) {\n        LPITEMIDLIST pidl;\n\n        if (SUCCEEDED (IPersistFolder2_GetCurFolder (ppf2, &pidl))) {\n            SHGetPathFromIDListW (pidl, wszSrcPathRoot);\n            if (This->sPathTarget)\n                lstrcpynW(wszDstPath, This->sPathTarget, MAX_PATH);\n            else\n                wszDstPath[0] = 0;\n            PathAddBackslashW(wszSrcPathRoot);\n            PathAddBackslashW(wszDstPath);\n            wszSrcPathsList = build_paths_list(wszSrcPathRoot, cidl, apidl);\n            ZeroMemory(&fop, sizeof(fop));\n            fop.hwnd = GetActiveWindow();\n            fop.wFunc = FO_COPY;\n            fop.pFrom = wszSrcPathsList;\n            fop.pTo = wszDstPath;\n            fop.fFlags = FOF_ALLOWUNDO;\n            ret = S_OK;\n            if(SHFileOperationW(&fop))\n            {\n                WARN(\"Copy failed\\n\");\n                ret = E_FAIL;\n            }\n            heap_free(wszSrcPathsList);\n        }\n        SHFree(pidl);\n        IPersistFolder2_Release(ppf2);\n    }\n    return ret;\n}\n\nstatic const ISFHelperVtbl shvt =\n{\n    ISFHelper_fnQueryInterface,\n    ISFHelper_fnAddRef,\n    ISFHelper_fnRelease,\n    ISFHelper_fnGetUniqueName,\n    ISFHelper_fnAddFolder,\n    ISFHelper_fnDeleteItems,\n    ISFHelper_fnCopyItems\n};\n\n/************************************************************************\n * IFSFldr_PersistFolder3_QueryInterface\n *\n */\nstatic HRESULT WINAPI IFSFldr_PersistFolder3_QueryInterface(IPersistFolder3 *iface, REFIID iid,\n        void **ppv)\n{\n    IGenericSFImpl *This = impl_from_IPersistFolder3(iface);\n\n    return IUnknown_QueryInterface(This->outer_unk, iid, ppv);\n}\n\n/************************************************************************\n * IFSFldr_PersistFolder3_AddRef\n *\n */\nstatic ULONG WINAPI IFSFldr_PersistFolder3_AddRef(IPersistFolder3 *iface)\n{\n    IGenericSFImpl *This = impl_from_IPersistFolder3(iface);\n\n    return IUnknown_AddRef(This->outer_unk);\n}\n\n/************************************************************************\n * IFSFldr_PersistFolder3_Release\n *\n */\nstatic ULONG WINAPI IFSFldr_PersistFolder3_Release(IPersistFolder3 *iface)\n{\n    IGenericSFImpl *This = impl_from_IPersistFolder3(iface);\n\n    return IUnknown_Release(This->outer_unk);\n}\n\n/************************************************************************\n * IFSFldr_PersistFolder3_GetClassID\n */\nstatic HRESULT WINAPI\nIFSFldr_PersistFolder3_GetClassID (IPersistFolder3 * iface, CLSID * lpClassId)\n{\n    IGenericSFImpl *This = impl_from_IPersistFolder3(iface);\n\n    TRACE (\"(%p)\\n\", This);\n\n    if (!lpClassId)\n        return E_POINTER;\n    *lpClassId = *This->pclsid;\n\n    return S_OK;\n}\n\n/************************************************************************\n * IFSFldr_PersistFolder3_Initialize\n *\n * NOTES\n *  sPathTarget is not set. Don't know how to handle in a non rooted environment.\n */\nstatic HRESULT WINAPI\nIFSFldr_PersistFolder3_Initialize (IPersistFolder3 * iface, LPCITEMIDLIST pidl)\n{\n    WCHAR wszTemp[MAX_PATH];\n    int len;\n    IGenericSFImpl *This = impl_from_IPersistFolder3(iface);\n\n    TRACE (\"(%p)->(%p)\\n\", This, pidl);\n\n    wszTemp[0] = 0;\n\n    SHFree (This->pidlRoot);     /* free the old pidl */\n    This->pidlRoot = ILClone (pidl); /* set my pidl */\n\n    /* FolderShortcuts' Initialize method only sets the ITEMIDLIST, which\n     * specifies the location in the shell namespace, but leaves the\n     * target folder alone */\n    if (IsEqualCLSID( This->pclsid, &CLSID_FolderShortcut )) return S_OK;\n\n    SHFree (This->sPathTarget);\n    This->sPathTarget = NULL;\n\n    /* set my path */\n    if (_ILIsSpecialFolder(pidl) && IsEqualCLSID( This->pclsid, _ILGetGUIDPointer(pidl) ))\n    {\n        if (IsEqualCLSID( This->pclsid, &CLSID_MyDocuments ))\n        {\n            if (!SHGetSpecialFolderPathW( 0, wszTemp, CSIDL_PERSONAL, FALSE )) return E_FAIL;\n            PathAddBackslashW( wszTemp );\n        }\n        else lstrcpyW( wszTemp, L\"\\\\\\\\?\\\\unix\\\\\" );\n    }\n    else SHGetPathFromIDListW( pidl, wszTemp );\n\n    if ((len = lstrlenW(wszTemp)))\n    {\n        This->sPathTarget = SHAlloc((len + 1) * sizeof(WCHAR));\n        if (!This->sPathTarget) return E_OUTOFMEMORY;\n        memcpy(This->sPathTarget, wszTemp, (len + 1) * sizeof(WCHAR));\n    }\n\n    TRACE (\"--(%p)->(%s)\\n\", This, debugstr_w(This->sPathTarget));\n    return S_OK;\n}\n\n/**************************************************************************\n * IFSFldr_PersistFolder3_GetCurFolder\n */\nstatic HRESULT WINAPI\nIFSFldr_PersistFolder3_fnGetCurFolder (IPersistFolder3 * iface,\n                                       LPITEMIDLIST * pidl)\n{\n    IGenericSFImpl *This = impl_from_IPersistFolder3(iface);\n\n    TRACE (\"(%p)->(%p)\\n\", This, pidl);\n\n    if (!pidl) return E_POINTER;\n    *pidl = ILClone (This->pidlRoot);\n    return S_OK;\n}\n\n/**************************************************************************\n * IFSFldr_PersistFolder3_InitializeEx\n *\n * FIXME: error handling\n */\nstatic HRESULT WINAPI\nIFSFldr_PersistFolder3_InitializeEx (IPersistFolder3 * iface,\n                                     IBindCtx * pbc, LPCITEMIDLIST pidlRoot,\n                                     const PERSIST_FOLDER_TARGET_INFO * ppfti)\n{\n    WCHAR wszTemp[MAX_PATH];\n\n    IGenericSFImpl *This = impl_from_IPersistFolder3(iface);\n\n    TRACE (\"(%p)->(%p,%p,%p)\\n\", This, pbc, pidlRoot, ppfti);\n    if (ppfti)\n        TRACE (\"--%p %s %s 0x%08lx 0x%08x\\n\",\n         ppfti->pidlTargetFolder, debugstr_w (ppfti->szTargetParsingName),\n         debugstr_w (ppfti->szNetworkProvider), ppfti->dwAttributes,\n         ppfti->csidl);\n\n    pdump (pidlRoot);\n    if (ppfti && ppfti->pidlTargetFolder)\n        pdump (ppfti->pidlTargetFolder);\n\n    if (This->pidlRoot)\n    {\n        SHFree(This->pidlRoot);\n        This->pidlRoot = NULL;\n    }\n    if (This->sPathTarget)\n    {\n        SHFree(This->sPathTarget);\n        This->sPathTarget = NULL;\n    }\n\n    /*\n     * Root path and pidl\n     */\n    This->pidlRoot = ILClone (pidlRoot);\n\n    /*\n     *  the target folder is specified in csidl OR pidlTargetFolder OR\n     *  szTargetParsingName\n     */\n    if (ppfti) {\n        if (ppfti->csidl != -1) {\n            if (SHGetSpecialFolderPathW (0, wszTemp, ppfti->csidl,\n             ppfti->csidl & CSIDL_FLAG_CREATE)) {\n                int len = lstrlenW(wszTemp);\n                This->sPathTarget = SHAlloc((len + 1) * sizeof(WCHAR));\n                if (!This->sPathTarget)\n                    return E_OUTOFMEMORY;\n                memcpy(This->sPathTarget, wszTemp, (len + 1) * sizeof(WCHAR));\n            }\n        } else if (ppfti->szTargetParsingName[0]) {\n            int len = lstrlenW(ppfti->szTargetParsingName);\n            This->sPathTarget = SHAlloc((len + 1) * sizeof(WCHAR));\n            if (!This->sPathTarget)\n                return E_OUTOFMEMORY;\n            memcpy(This->sPathTarget, ppfti->szTargetParsingName,\n                   (len + 1) * sizeof(WCHAR));\n        } else if (ppfti->pidlTargetFolder) {\n            if (SHGetPathFromIDListW(ppfti->pidlTargetFolder, wszTemp)) {\n                int len = lstrlenW(wszTemp);\n                This->sPathTarget = SHAlloc((len + 1) * sizeof(WCHAR));\n                if (!This->sPathTarget)\n                    return E_OUTOFMEMORY;\n                memcpy(This->sPathTarget, wszTemp, (len + 1) * sizeof(WCHAR));\n            }\n        }\n    }\n\n    TRACE (\"--(%p)->(target=%s)\\n\", This, debugstr_w(This->sPathTarget));\n    pdump (This->pidlRoot);\n    return (This->sPathTarget) ? S_OK : E_FAIL;\n}\n\nstatic HRESULT WINAPI\nIFSFldr_PersistFolder3_GetFolderTargetInfo (IPersistFolder3 * iface,\n                                            PERSIST_FOLDER_TARGET_INFO * ppfti)\n{\n    IGenericSFImpl *This = impl_from_IPersistFolder3(iface);\n    FIXME (\"(%p)->(%p)\\n\", This, ppfti);\n    ZeroMemory (ppfti, sizeof (*ppfti));\n    return E_NOTIMPL;\n}\n\nstatic const IPersistFolder3Vtbl pfvt =\n{\n    IFSFldr_PersistFolder3_QueryInterface,\n    IFSFldr_PersistFolder3_AddRef,\n    IFSFldr_PersistFolder3_Release,\n    IFSFldr_PersistFolder3_GetClassID,\n    IFSFldr_PersistFolder3_Initialize,\n    IFSFldr_PersistFolder3_fnGetCurFolder,\n    IFSFldr_PersistFolder3_InitializeEx,\n    IFSFldr_PersistFolder3_GetFolderTargetInfo\n};\n\n/****************************************************************************\n * IPersistPropertyBag implementation\n */\nstatic HRESULT WINAPI PersistPropertyBag_QueryInterface(IPersistPropertyBag* iface,\n    REFIID riid, void** ppv)\n{\n    IGenericSFImpl *This = impl_from_IPersistPropertyBag(iface);\n    return IUnknown_QueryInterface(This->outer_unk, riid, ppv);\n}\n\nstatic ULONG WINAPI PersistPropertyBag_AddRef(IPersistPropertyBag* iface)\n{\n    IGenericSFImpl *This = impl_from_IPersistPropertyBag(iface);\n    return IUnknown_AddRef(This->outer_unk);\n}\n\nstatic ULONG WINAPI PersistPropertyBag_Release(IPersistPropertyBag* iface)\n{\n    IGenericSFImpl *This = impl_from_IPersistPropertyBag(iface);\n    return IUnknown_Release(This->outer_unk);\n}\n\nstatic HRESULT WINAPI PersistPropertyBag_GetClassID(IPersistPropertyBag* iface, CLSID* pClassID)\n{\n    IGenericSFImpl *This = impl_from_IPersistPropertyBag(iface);\n    return IPersistFolder3_GetClassID(&This->IPersistFolder3_iface, pClassID);\n}\n\nstatic HRESULT WINAPI PersistPropertyBag_InitNew(IPersistPropertyBag* iface)\n{\n    IGenericSFImpl *This = impl_from_IPersistPropertyBag(iface);\n    FIXME(\"(%p): stub\\n\", This);\n    return E_NOTIMPL;\n}\n\nstatic HRESULT WINAPI PersistPropertyBag_Load(IPersistPropertyBag *iface,\n    IPropertyBag *pPropertyBag, IErrorLog *pErrorLog)\n{\n    IGenericSFImpl *This = impl_from_IPersistPropertyBag(iface);\n    PERSIST_FOLDER_TARGET_INFO pftiTarget;\n    VARIANT var;\n    HRESULT hr;\n\n    TRACE(\"(%p)->(%p %p)\\n\", This, pPropertyBag, pErrorLog);\n\n    if (!pPropertyBag)\n        return E_POINTER;\n\n    /* Get 'Target' property from the property bag. */\n    V_VT(&var) = VT_BSTR;\n    hr = IPropertyBag_Read(pPropertyBag, L\"Target\", &var, NULL);\n    if (FAILED(hr))\n        return E_FAIL;\n    lstrcpyW(pftiTarget.szTargetParsingName, V_BSTR(&var));\n    SysFreeString(V_BSTR(&var));\n\n    pftiTarget.pidlTargetFolder = NULL;\n    pftiTarget.szNetworkProvider[0] = 0;\n    pftiTarget.dwAttributes = -1;\n    pftiTarget.csidl = -1;\n\n    return IPersistFolder3_InitializeEx(&This->IPersistFolder3_iface, NULL, NULL, &pftiTarget);\n}\n\nstatic HRESULT WINAPI PersistPropertyBag_Save(IPersistPropertyBag *iface,\n    IPropertyBag *pPropertyBag, BOOL fClearDirty, BOOL fSaveAllProperties)\n{\n    IGenericSFImpl *This = impl_from_IPersistPropertyBag(iface);\n    FIXME(\"(%p): stub\\n\", This);\n    return E_NOTIMPL;\n}\n\nstatic const IPersistPropertyBagVtbl ppbvt = {\n    PersistPropertyBag_QueryInterface,\n    PersistPropertyBag_AddRef,\n    PersistPropertyBag_Release,\n    PersistPropertyBag_GetClassID,\n    PersistPropertyBag_InitNew,\n    PersistPropertyBag_Load,\n    PersistPropertyBag_Save\n};\n\n/****************************************************************************\n * ISFDropTarget implementation\n */\nstatic HRESULT WINAPI ISFDropTarget_QueryInterface(IDropTarget *iface, REFIID riid, void **ppv)\n{\n    IGenericSFImpl *This = impl_from_IDropTarget(iface);\n\n    return IUnknown_QueryInterface(This->outer_unk, riid, ppv);\n}\n\nstatic ULONG WINAPI ISFDropTarget_AddRef(IDropTarget *iface)\n{\n    IGenericSFImpl *This = impl_from_IDropTarget(iface);\n\n    return IUnknown_AddRef(This->outer_unk);\n}\n\nstatic ULONG WINAPI ISFDropTarget_Release(IDropTarget *iface)\n{\n    IGenericSFImpl *This = impl_from_IDropTarget(iface);\n\n    return IUnknown_Release(This->outer_unk);\n}\n\n#define HIDA_GetPIDLFolder(pida) (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])\n#define HIDA_GetPIDLItem(pida, i) (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])\n\nstatic HRESULT WINAPI\nISFDropTarget_DragEnter (IDropTarget * iface, IDataObject * pDataObject,\n                         DWORD dwKeyState, POINTL pt, DWORD * pdwEffect)\n{\n    IGenericSFImpl *This = impl_from_IDropTarget(iface);\n    FORMATETC format;\n    STGMEDIUM medium;\n\n    TRACE(\"(%p)->(%p 0x%08lx {.x=%ld, .y=%ld} %p)\\n\", This, pDataObject, dwKeyState, pt.x, pt.y, pdwEffect);\n\n    if (!pdwEffect || !pDataObject)\n        return E_INVALIDARG;\n\n    /* Compute a mask of supported drop-effects for this shellfolder object and the given data\n     * object. Dropping is only supported on folders, which represent filesystem locations. One\n     * can't drop on file objects. And the 'move' drop effect is only supported, if the source\n     * folder is not identical to the target folder. */\n    This->drop_effects_mask = DROPEFFECT_NONE;\n    InitFormatEtc(format, cfShellIDList, TYMED_HGLOBAL);\n    if (_ILIsFolder(ILFindLastID(This->pidlRoot)) && /* Only drop to folders, not to files */\n        SUCCEEDED(IDataObject_GetData(pDataObject, &format, &medium))) /* Only ShellIDList format */\n    {\n        LPIDA pidaShellIDList = GlobalLock(medium.u.hGlobal);\n        This->drop_effects_mask |= DROPEFFECT_COPY|DROPEFFECT_LINK;\n\n        if (pidaShellIDList) { /* Files can only be moved between two different folders */\n            if (!ILIsEqual(HIDA_GetPIDLFolder(pidaShellIDList), This->pidlRoot))\n                This->drop_effects_mask |= DROPEFFECT_MOVE;\n            GlobalUnlock(medium.u.hGlobal);\n        }\n    }\n\n    *pdwEffect = KeyStateToDropEffect(dwKeyState) & This->drop_effects_mask;\n\n    return S_OK;\n}\n\nstatic HRESULT WINAPI\nISFDropTarget_DragOver (IDropTarget * iface, DWORD dwKeyState, POINTL pt,\n                        DWORD * pdwEffect)\n{\n    IGenericSFImpl *This = impl_from_IDropTarget(iface);\n\n    TRACE(\"(%p)->(0x%08lx {.x=%ld, .y=%ld} %p)\\n\", This, dwKeyState, pt.x, pt.y, pdwEffect);\n\n    if (!pdwEffect)\n        return E_INVALIDARG;\n\n    *pdwEffect = KeyStateToDropEffect(dwKeyState) & This->drop_effects_mask;\n\n    return S_OK;\n}\n\nstatic HRESULT WINAPI ISFDropTarget_DragLeave (IDropTarget * iface)\n{\n    IGenericSFImpl *This = impl_from_IDropTarget(iface);\n\n    TRACE(\"(%p)\\n\", This);\n\n    This->drop_effects_mask = DROPEFFECT_NONE;\n    return S_OK;\n}\n\nstatic HRESULT WINAPI\nISFDropTarget_Drop (IDropTarget * iface, IDataObject * pDataObject,\n                    DWORD dwKeyState, POINTL pt, DWORD * pdwEffect)\n{\n    IGenericSFImpl *This = impl_from_IDropTarget(iface);\n    FORMATETC format;\n    STGMEDIUM medium;\n    HRESULT hr;\n\n    TRACE(\"(%p)->(%p %ld {.x=%ld, .y=%ld} %p) semi-stub\\n\",\n        This, pDataObject, dwKeyState, pt.x, pt.y, pdwEffect);\n\n    InitFormatEtc(format, cfShellIDList, TYMED_HGLOBAL);\n    hr = IDataObject_GetData(pDataObject, &format, &medium);\n    if (FAILED(hr))\n        return hr;\n\n    if (medium.tymed == TYMED_HGLOBAL) {\n        IShellFolder *psfSourceFolder, *psfDesktopFolder;\n        LPIDA pidaShellIDList = GlobalLock(medium.u.hGlobal);\n        STRRET strret;\n        UINT i;\n\n        if (!pidaShellIDList)\n            return HRESULT_FROM_WIN32(GetLastError());\n\n        hr = SHGetDesktopFolder(&psfDesktopFolder);\n        if (FAILED(hr)) {\n            GlobalUnlock(medium.u.hGlobal);\n            return hr;\n        }\n\n        hr = IShellFolder_BindToObject(psfDesktopFolder, HIDA_GetPIDLFolder(pidaShellIDList), NULL,\n                                       &IID_IShellFolder, (LPVOID*)&psfSourceFolder);\n        IShellFolder_Release(psfDesktopFolder);\n        if (FAILED(hr)) {\n            GlobalUnlock(medium.u.hGlobal);\n            return hr;\n        }\n\n        for (i = 0; i < pidaShellIDList->cidl; i++) {\n            WCHAR wszSourcePath[MAX_PATH];\n\n            hr = IShellFolder_GetDisplayNameOf(psfSourceFolder, HIDA_GetPIDLItem(pidaShellIDList, i),\n                                               SHGDN_FORPARSING, &strret);\n            if (FAILED(hr))\n                break;\n\n            hr = StrRetToBufW(&strret, NULL, wszSourcePath, MAX_PATH);\n            if (FAILED(hr))\n                break;\n\n            switch (*pdwEffect) {\n                case DROPEFFECT_MOVE:\n                    FIXME(\"Move %s to %s!\\n\", debugstr_w(wszSourcePath), debugstr_w(This->sPathTarget));\n                    break;\n                case DROPEFFECT_COPY:\n                    FIXME(\"Copy %s to %s!\\n\", debugstr_w(wszSourcePath), debugstr_w(This->sPathTarget));\n                    break;\n                case DROPEFFECT_LINK:\n                    FIXME(\"Link %s from %s!\\n\", debugstr_w(wszSourcePath), debugstr_w(This->sPathTarget));\n                    break;\n            }\n        }\n\n        IShellFolder_Release(psfSourceFolder);\n        GlobalUnlock(medium.u.hGlobal);\n        return hr;\n    }\n\n    return E_NOTIMPL;\n}\n\nstatic const IDropTargetVtbl dtvt = {\n    ISFDropTarget_QueryInterface,\n    ISFDropTarget_AddRef,\n    ISFDropTarget_Release,\n    ISFDropTarget_DragEnter,\n    ISFDropTarget_DragOver,\n    ISFDropTarget_DragLeave,\n    ISFDropTarget_Drop\n};\n\nstatic HRESULT create_fs( IUnknown *outer_unk, REFIID riid, void **ppv, const CLSID *clsid)\n{\n    IGenericSFImpl *sf;\n    HRESULT hr;\n\n    TRACE(\"outer_unk=%p %s\\n\", outer_unk, shdebugstr_guid(riid));\n\n    if (outer_unk && !IsEqualIID(riid, &IID_IUnknown))\n        return CLASS_E_NOAGGREGATION;\n\n    sf = LocalAlloc(LMEM_ZEROINIT, sizeof(*sf));\n    if (!sf)\n        return E_OUTOFMEMORY;\n\n    sf->ref = 1;\n    sf->IUnknown_inner.lpVtbl = &unkvt;\n    sf->IShellFolder2_iface.lpVtbl = &sfvt;\n    sf->IPersistFolder3_iface.lpVtbl = &pfvt;\n    sf->IPersistPropertyBag_iface.lpVtbl = &ppbvt;\n    sf->IDropTarget_iface.lpVtbl = &dtvt;\n    sf->ISFHelper_iface.lpVtbl = &shvt;\n    sf->pclsid = clsid;\n    sf->outer_unk = outer_unk ? outer_unk : &sf->IUnknown_inner;\n\n    hr = IUnknown_QueryInterface(&sf->IUnknown_inner, riid, ppv);\n    IUnknown_Release(&sf->IUnknown_inner);\n\n    TRACE (\"--%p\\n\", *ppv);\n    return hr;\n}\n\nHRESULT WINAPI IFSFolder_Constructor(IUnknown *outer_unk, REFIID riid, void **ppv)\n{\n    return create_fs( outer_unk, riid, ppv, &CLSID_ShellFSFolder );\n}\n\nHRESULT WINAPI UnixFolder_Constructor(IUnknown *outer_unk, REFIID riid, void **ppv)\n{\n    return create_fs( outer_unk, riid, ppv, &CLSID_UnixFolder );\n}\n\nHRESULT WINAPI UnixDosFolder_Constructor(IUnknown *outer_unk, REFIID riid, void **ppv)\n{\n    return create_fs( outer_unk, riid, ppv, &CLSID_UnixDosFolder );\n}\n\nHRESULT WINAPI FolderShortcut_Constructor(IUnknown *outer_unk, REFIID riid, void **ppv)\n{\n    return create_fs( outer_unk, riid, ppv, &CLSID_FolderShortcut );\n}\n\nHRESULT WINAPI MyDocuments_Constructor(IUnknown *outer_unk, REFIID riid, void **ppv)\n{\n    return create_fs( outer_unk, riid, ppv, &CLSID_MyDocuments );\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dlls/shell32/shfldr_fs.c b/dlls/shell32/shfldr_fs.c
--- a/dlls/shell32/shfldr_fs.c	(revision 3c875fb65750ab683d74d606b39a964855a6259f)
+++ b/dlls/shell32/shfldr_fs.c	(date 1694966578023)
@@ -295,7 +295,7 @@
 
     HRESULT hr = S_OK;
     LPCWSTR szNext = NULL;
-    WCHAR *p, szPath[MAX_PATH];
+    WCHAR szPath[MAX_PATH];
     WIN32_FIND_DATAW find_data = { 0 };
     IFileSystemBindData *fsbd = NULL;
     LPITEMIDLIST pidlTemp = NULL;
@@ -305,7 +305,7 @@
      This, hwndOwner, pbc, lpszDisplayName, debugstr_w (lpszDisplayName),
      pchEaten, ppidl, pdwAttributes);
 
-    if (!lpszDisplayName || !lpszDisplayName[0] || !ppidl) return E_INVALIDARG;
+    if (!lpszDisplayName || !ppidl) return E_INVALIDARG;
 
     if (pchEaten)
         *pchEaten = 0; /* strange but like the original */
@@ -331,30 +331,6 @@
         /* get the next element */
         szNext = GetNextElementW( lpszDisplayName, szPath + len, MAX_PATH - len );
 
-        if (IsEqualCLSID( This->pclsid, &CLSID_UnixFolder ) && lpszDisplayName[0] == '/')
-        {
-            lstrcpynW( szPath + len, lpszDisplayName + 1, MAX_PATH - len );
-            for (p = szPath + len; *p; p++) if (*p == '/') *p = '\\';
-        }
-        else if (!wcsnicmp( lpszDisplayName, L"\\\\?\\unix\\", 9 ))
-        {
-            lstrcpynW( szPath + len, lpszDisplayName + 9, MAX_PATH - len );
-            if ((p = wcschr( szPath + len, '\\' )))
-                while (*p == '\\') *p++ = 0;
-            szNext = p;
-        }
-
-        /* Special case for the root folder. */
-        if (!wcsicmp( szPath, L"\\\\?\\unix\\" ))
-        {
-            *ppidl = SHAlloc(sizeof(USHORT));
-            if (!*ppidl) return E_FAIL;
-            (*ppidl)->mkid.cb = 0; /* Terminate the ITEMIDLIST */
-            return S_OK;
-        }
-
-        PathRemoveBackslashW( szPath );
-
         if (szNext && *szNext)
         {
             hr = _ILCreateFromPathW( szPath, &pidlTemp );
@@ -435,15 +411,11 @@
                              LPBC pbc, REFIID riid, LPVOID * ppvOut)
 {
     IGenericSFImpl *This = impl_from_IShellFolder2(iface);
-    const CLSID *clsid = This->pclsid;
 
     TRACE ("(%p)->(pidl=%p,%p,%s,%p)\n", This, pidl, pbc,
      shdebugstr_guid (riid), ppvOut);
 
-    if (!IsEqualCLSID( clsid, &CLSID_UnixFolder ) && !IsEqualCLSID( clsid, &CLSID_UnixDosFolder ))
-        clsid = &CLSID_ShellFSFolder;
-
-    return SHELL32_BindToChild (This->pidlRoot, clsid, This->sPathTarget, pidl, riid, ppvOut);
+    return SHELL32_BindToChild (This->pidlRoot, This->pclsid, This->sPathTarget, pidl, riid, ppvOut);
 }
 
 /**************************************************************************
@@ -551,18 +523,10 @@
         IShellFolder2 *parent = NULL;
         LPCITEMIDLIST rpidl = NULL;
 
-        if (_ILIsSpecialFolder(This->pidlRoot))
-        {
-            *rgfInOut &= (SFGAO_HASSUBFOLDER | SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_FILESYSANCESTOR |
-                          SFGAO_DROPTARGET | SFGAO_HASPROPSHEET | SFGAO_CANRENAME);
-        }
-        else
-        {
-            hr = SHBindToParent(This->pidlRoot, &IID_IShellFolder2, (void **)&parent, &rpidl);
-            if(SUCCEEDED(hr)) {
-                SHELL32_GetItemAttributes(parent, rpidl, rgfInOut);
-                IShellFolder2_Release(parent);
-            }
+        hr = SHBindToParent(This->pidlRoot, &IID_IShellFolder2, (void **)&parent, &rpidl);
+        if(SUCCEEDED(hr)) {
+            SHELL32_GetItemAttributes(parent, rpidl, rgfInOut);
+            IShellFolder2_Release(parent);
         }
     }
     else {
@@ -795,41 +759,6 @@
     }
 }
 
-static void get_display_name( WCHAR dest[MAX_PATH], const WCHAR *path, LPCITEMIDLIST pidl, BOOL is_unix )
-{
-    char *buffer;
-    WCHAR *res;
-    DWORD i, len;
-
-    lstrcpynW( dest, path, MAX_PATH );
-
-    /* try to get a better path than the \\?\unix one */
-    if (!wcsnicmp( path, L"\\\\?\\unix\\", 9 ))
-    {
-        if (!is_unix)
-        {
-            len = WideCharToMultiByte( CP_UNIXCP, 0, path + 8, -1, NULL, 0, NULL, NULL );
-            buffer = heap_alloc( len );
-            len = WideCharToMultiByte( CP_UNIXCP, 0, path + 8, -1, buffer, len, NULL, NULL );
-            for (i = 0; i < len; i++) if (buffer[i] == '\\') buffer[i] = '/';
-            if ((res = wine_get_dos_file_name( buffer )))
-            {
-                lstrcpynW( dest, res, MAX_PATH );
-                heap_free( res );
-            }
-        }
-        else lstrcpynW( dest, path + 8, MAX_PATH );
-    }
-
-    if (!_ILIsDesktop(pidl))
-    {
-        PathAddBackslashW( dest );
-        len = lstrlenW( dest );
-        _ILSimpleGetTextW( pidl, dest + len, MAX_PATH - len );
-    }
-    if (is_unix) for (i = 0; dest[i]; i++) if (dest[i] == '\\') dest[i] = '/';
-}
-
 /**************************************************************************
 *  IShellFolder_fnGetDisplayNameOf
 *  Retrieves the display name for the specified file object or subfolder
@@ -851,11 +780,12 @@
     LPWSTR pszPath;
 
     HRESULT hr = S_OK;
+    int len = 0;
 
     TRACE ("(%p)->(pidl=%p,0x%08lx,%p)\n", This, pidl, dwFlags, strRet);
     pdump (pidl);
 
-    if (!strRet)
+    if (!pidl || !strRet)
         return E_INVALIDARG;
 
     pszPath = CoTaskMemAlloc((MAX_PATH +1) * sizeof(WCHAR));
@@ -867,8 +797,7 @@
             (GET_SHGDN_RELATION(dwFlags) != SHGDN_INFOLDER))
         {
             if (This->sPathTarget)
-                get_display_name( pszPath, This->sPathTarget, pidl,
-                                  IsEqualCLSID( This->pclsid, &CLSID_UnixFolder ));
+                lstrcpynW(pszPath, This->sPathTarget, MAX_PATH);
         } else {
             /* pidl has to contain exactly one non null SHITEMID */
             hr = E_INVALIDARG;
@@ -878,10 +807,11 @@
             (GET_SHGDN_RELATION(dwFlags) != SHGDN_INFOLDER) &&
             This->sPathTarget)
         {
-            get_display_name( pszPath, This->sPathTarget, pidl,
-                              IsEqualCLSID( This->pclsid, &CLSID_UnixFolder ));
+            lstrcpynW(pszPath, This->sPathTarget, MAX_PATH);
+            PathAddBackslashW(pszPath);
+            len = lstrlenW(pszPath);
         }
-        else _ILSimpleGetTextW(pidl, pszPath, MAX_PATH);
+        _ILSimpleGetTextW(pidl, pszPath + len, MAX_PATH + 1 - len);
         if (!_ILIsFolder(pidl)) SHELL_FS_ProcessDisplayFilename(pszPath, dwFlags);
     } else {
         hr = SHELL32_GetDisplayNameOfChild(iface, pidl, dwFlags, pszPath, MAX_PATH);
@@ -1442,38 +1372,20 @@
 IFSFldr_PersistFolder3_Initialize (IPersistFolder3 * iface, LPCITEMIDLIST pidl)
 {
     WCHAR wszTemp[MAX_PATH];
-    int len;
     IGenericSFImpl *This = impl_from_IPersistFolder3(iface);
 
     TRACE ("(%p)->(%p)\n", This, pidl);
 
-    wszTemp[0] = 0;
-
     SHFree (This->pidlRoot);     /* free the old pidl */
     This->pidlRoot = ILClone (pidl); /* set my pidl */
 
-    /* FolderShortcuts' Initialize method only sets the ITEMIDLIST, which
-     * specifies the location in the shell namespace, but leaves the
-     * target folder alone */
-    if (IsEqualCLSID( This->pclsid, &CLSID_FolderShortcut )) return S_OK;
-
     SHFree (This->sPathTarget);
     This->sPathTarget = NULL;
 
     /* set my path */
-    if (_ILIsSpecialFolder(pidl) && IsEqualCLSID( This->pclsid, _ILGetGUIDPointer(pidl) ))
-    {
-        if (IsEqualCLSID( This->pclsid, &CLSID_MyDocuments ))
-        {
-            if (!SHGetSpecialFolderPathW( 0, wszTemp, CSIDL_PERSONAL, FALSE )) return E_FAIL;
-            PathAddBackslashW( wszTemp );
-        }
-        else lstrcpyW( wszTemp, L"\\\\?\\unix\\" );
-    }
-    else SHGetPathFromIDListW( pidl, wszTemp );
 
-    if ((len = lstrlenW(wszTemp)))
-    {
+    if (SHGetPathFromIDListW (pidl, wszTemp)) {
+        int len = lstrlenW(wszTemp);
         This->sPathTarget = SHAlloc((len + 1) * sizeof(WCHAR));
         if (!This->sPathTarget) return E_OUTOFMEMORY;
         memcpy(This->sPathTarget, wszTemp, (len + 1) * sizeof(WCHAR));
